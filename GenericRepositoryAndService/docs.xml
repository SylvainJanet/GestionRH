<?xml version="1.0"?>
<doc>
	<assembly>
		<name>GenericRepositoryAndService</name>
	</assembly>
	<members>
		<member name="T:GenericRepositoryAndService.Models.BaseEntity">
			<summary>
				Every classes with an Id have to derive from this class to be
				properly handled by the generic repository and service
				<br/>
				Furthermore,
				<list type = "bullet" >
					<item>
						For a class t with name "TName", the corresponding repository has to be named "TNameRepository"
					</item>
					<item>
						For a class t with name "TName", the corresponding service has to be named "TNameService"
					</item>
				</list>
			</summary>
		</member>
		<member name="T:GenericRepositoryAndService.Models.EntityWithKeys">
			<summary>
				Every classes with at least one property with annotation <see cref="T:System.ComponentModel.DataAnnotations.KeyAttribute"/>
				have to derive from this class to be properly handled by the
				generic repository and service
				<br/>
				Furthermore,
				<list type="bullet">
					<item>
						For a class t with name "TName", the corresponding repository has to be named "TNameRepository"
					</item>
					<item>
						For a class t with name "TName", the corresponding service has to be named "TNameService"
					</item>
				</list>
			</summary>
		</member>
		<member name="M:GenericRepositoryAndService.Models.EntityWithKeys.KeysToDisplayString(GenericRepositoryAndService.Models.EntityWithKeys)">
			<summary>
				Converts an object of type <see cref="T:GenericRepositoryAndService.Models.EntityWithKeys"/> to a string used
				to display its keys. The reverse operation is <see cref="M:GenericRepositoryAndService.Models.EntityWithKeys.DisplayStringToKeys(System.String)"/>
			</summary>
			<param name="e">
				The object of type <see cref="T:GenericRepositoryAndService.Models.EntityWithKeys"/>
			</param>
			<returns>The string displayed</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Models.EntityWithKeys.DisplayStringToKeys(System.String)">
			<summary>
				The reverse operation of <see cref="M:GenericRepositoryAndService.Models.EntityWithKeys.KeysToDisplayString(GenericRepositoryAndService.Models.EntityWithKeys)"/>. From a string used
				to display the key of an object of type <see cref="T:GenericRepositoryAndService.Models.EntityWithKeys"/>, get the keys as
				<see cref="T:System.Object"/>[].
			</summary>
			<remarks>
				Has to be redifined for every class deriving from <see cref="T:GenericRepositoryAndService.Models.EntityWithKeys"/>.
			</remarks>
			<param name="s">The string of keys</param>
			<returns>
				The keys as <see cref="T:System.Object"/>[]
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.ClassHasToImplementDisplayStringToKeysException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Models.EntityWithKeys.KeysToDisplayString">
			<summary>
				Create a new definition for <see cref="M:GenericRepositoryAndService.Models.EntityWithKeys.DisplayStringToKeys(System.String)"/>
				<br/>
				<example>
					For instance, for a class with a single key
					<br/>
					<code>
						public override string KeysToDisplayString() <br/>
						{ <br/>
						retrun this.keypropertyname.ToString(); <br/>
						}
					</code>
				</example>
			</summary>
		</member>
		<member name="T:GenericRepositoryAndService.Repository.GenericRepository`1">
			<summary>
				Generic Repository for class <typeparamref name="T"/> using context
				type <see cref="T:System.Data.Entity.DbContext"/>.
				<remark>
					Assumes every class that either derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					or has at least one property with annotation <see cref="T:System.ComponentModel.DataAnnotations.KeyAttribute"/>
					has a <see cref="T:System.Data.Entity.DbSet"/> in <see cref="T:System.Data.Entity.DbContext"/>.
					<br/>
					And that reciprocally, every class having a <see cref="T:System.Data.Entity.DbSet"/> in
					<see cref="T:System.Data.Entity.DbContext"/> either derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					or has at least one property with annotation <see cref="T:System.ComponentModel.DataAnnotations.KeyAttribute"/>.
				</remark>
			</summary>
			<typeparam name="T"></typeparam>
		</member>
		<member name="F:GenericRepositoryAndService.Repository.GenericRepository`1._DynamicDBListTypes">
			<summary>
				An object <c>obj</c> of class <typeparamref name="T"/> has properties <c>obj.PropName</c> of
				class <see cref="T:System.Collections.IList"/>&lt;<c>ClassType</c>&gt; where <c>ClassType</c> is in a <see cref="T:System.Data.Entity.DbSet"/> of the generic repository
				<see cref="F:GenericRepositoryAndService.Repository.GenericRepository`1.DataContext"/>.
				<br/>
				This is every { PropName : ClassType }
			</summary>
		</member>
		<member name="F:GenericRepositoryAndService.Repository.GenericRepository`1._DynamicDBTypes">
			<summary>
				An object <c>obj</c> of class <typeparamref name="T"/> has properties <c>obj.PropName</c> of
				class <c>ClassType</c> which is in a <see cref="T:System.Data.Entity.DbSet"/> of the generic repository
				<see cref="F:GenericRepositoryAndService.Repository.GenericRepository`1.DataContext"/>.
				<br/>
				This is every { PropName : ClassType }
			</summary>
		</member>
		<member name="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam">
			<summary>
				Custom class to handle types in a relationship with <typeparamref name="T"/>
				<br/>
				Specifically to store the type of another class in a many-to-many or one-to-many or one-to-one
				relationship with <typeparamref name="T"/>
				<br/>
				<para>
					i.e. store the type <see cref="P:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam.TypeofElement"/> such that :
					<list type="bullet">
						<item>
							<description>
								the class <typeparamref name="T"/> has a property of type either:
								<list type="bullet">
									<item>
										<description>
											<see cref="P:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam.TypeofElement"/>
										</description>
									</item>
									<item>
										<description>
											or <see cref="T:System.Collections.IList"/>&lt;<see cref="P:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam.TypeofElement"/>&gt;
										</description>
									</item>
								</list>
							</description>
						</item>
						<item>
							<description>
								<see cref="P:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam.TypeofElement"/> is in a <see cref="T:System.Data.Entity.DbSet"/> of the generic repository <see cref="F:GenericRepositoryAndService.Repository.GenericRepository`1.DataContext"/>
							</description>
						</item>
					</list>
				</para>
				<remark>
					Code could be refactored and dismiss this class, since <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.TryListOfWhat(System.Type,System.Type@)"/> does the job <br/>
					I didn't know it was possible when I coded the handling of relationships  and found out about that possibility when I was about to finish
					a huge chunk of this code
				</remark>
			</summary>
		</member>
		<member name="P:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam.Value">
			<summary>
				The value of the property of <typeparamref name="T"/>
			</summary>
		</member>
		<member name="P:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam.TypeofElement">
			<summary>
				The property of <typeparamref name="T"/> is of type <see cref="T:System.Collections.IList"/>&lt;<see cref="P:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam.TypeofElement"/>&gt;
			</summary>
		</member>
		<member name="P:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam.PropertyName">
			<summary>
				The name of the property. The property <see cref="P:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam.Prop"/> of an object <c>obj</c> of class <typeparamref name="T"/> is <c>obj.PropertyName</c>
			</summary>
		</member>
		<member name="P:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam.Prop">
			<summary>
				The property
			</summary>
		</member>
		<member name="P:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam.IsList">
			<summary>
				boolean to indicate if the property <see cref="P:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam.Prop"/> of class <typeparamref name="T"/> is a <see cref="T:System.Collections.IList"/> or not.
			</summary>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam.#ctor(System.Object,System.Type,System.String,System.Reflection.PropertyInfo,System.Boolean)">
			<summary>
				Construc a new CustomParam, storing type information for properties representing relationships in DB with <typeparamref name="T"/>.
			</summary>
			<param name="value">
				The value of the property of <typeparamref name="T"/>
			</param>
			<param name="typeofElement">
				The property of <typeparamref name="T"/> is of type <see cref="T:System.Collections.IList"/>&lt;<see cref="P:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam.TypeofElement"/>&gt;
			</param>
			<param name="propertyName">
				The name of the property. The property <see cref="P:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam.Prop"/> of an object <c>obj</c> of class <typeparamref name="T"/> is <c>obj.PropertyName</c>
			</param>
			<param name="prop">The property</param>
			<param name="isList">
				boolean to indicate if the property <see cref="P:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam.Prop"/> of class <typeparamref name="T"/> is a <see cref="T:System.Collections.IList"/> or not.
			</param>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.Add(`0)">
			<summary>
				Adds an element <paramref name="t"/> in DB of type <typeparamref name="T"/>
				<br/>
				Throws exception <see cref="T:GenericRepositoryAndService.Exceptions.CascadeCreationInDBException"/> if <typeparamref name="T"/> is in a relationship with a class in a <see cref="T:System.Data.Entity.DbSet"/> of <see cref="F:GenericRepositoryAndService.Repository.GenericRepository`1.DataContext"/>.
				These elements could be dublicated in DB otherwise, they could be loaded in the context.
			</summary>
			<param name="t">Element to add</param>
			<exception cref="T:GenericRepositoryAndService.Exceptions.CascadeCreationInDBException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.Collection(System.Boolean,System.Boolean)">
			<summary>
				Get the IQueryable collection. Specify if all other types in relationship with <typeparamref name="T"/>
				have to be included in the query, and if the elements have to be tracked.
			</summary>
			<param name="isIncludes">
				Whether or not other types in relationship with <typeparamref name="T"/>
				have to be included in the query
			</param>
			<param name="isTracked">Whether or not elements have to be tracked</param>
			<returns>The IQueryable collection</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.CollectionExcludes">
			<summary>
				Get the IQueryable collection, other types in relationship with <typeparamref name="T"/> excluded, elements not tracked.
			</summary>
			<returns>The query</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.CollectionExcludesTracked">
			<summary>
				Get the IQueryable collection, other types in relationship with <typeparamref name="T"/> excluded, elements tracked.
			</summary>
			<returns>The query</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.CollectionIncludes">
			<summary>
				Get the IQueryable collection, other types in relationship with <typeparamref name="T"/> included, elements not tracked.
			</summary>
			<returns>The query</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.CollectionIncludesTracked">
			<summary>
				Get the IQueryable collection, other types in relationship with <typeparamref name="T"/> included, elements tracked.
			</summary>
			<returns>The query</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.Commit">
			<summary>
				Commit the changes in DB
			</summary>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.Count(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Counts the elements in DB for which the predicate <paramref name="predicateWhere"/> is <see langword="true"/>.
			</summary>
			<remarks>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</remarks>
			<param name="predicateWhere"></param>
			<returns>
				The number of elements in DB satisfying <paramref name="predicateWhere"/>
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.Delete(System.Object[])">
			<summary>
				Deletes an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Id of the object to delete, or its keys values.</param>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.Delete(`0)">
			<summary>
				Deletes a specific object <paramref name="t"/> of type <typeparamref name="T"/> from DB
			</summary>
			<param name="t">The object to delete</param>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.FindById(System.Boolean,System.Boolean,System.Object[])">
			<summary>
				Finds an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
				Specify if all other types in relationship with <typeparamref name="T"/>
				have to be included in the query, and if the elements have to be tracked
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="isIncludes">
				Whether or not other types in relationship with <typeparamref name="T"/>
				have to be included in the query
			</param>
			<param name="isTracked">Whether or not elements have to be tracked</param>
			<param name="objs">Either the Id of the object to find, or its keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.FindByIdExcludes(System.Object[])">
			<summary>
				Finds an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> excluded, elements not tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Id of the object to find, or its keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.FindByIdExcludesTracked(System.Object[])">
			<summary>
				Finds an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> excluded, elements tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Id of the object to find, or its keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.FindByIdIncludes(System.Object[])">
			<summary>
				Finds an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> included, elements not tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Id of the object to find, or its keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.FindByIdIncludesTracked(System.Object[])">
			<summary>
				Finds an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> included, elements tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Id of the object to find, or its keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name ="M:GenericRepositoryAndService.Repository.GenericRepository`1.GetAllBy(System.Boolean,System.Boolean,System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				  Get a list of elements following condition <paramref name="predicateWhere"/>.
				 <br/>
				 Every other property will be excluded if and only if <paramref name="isIncludes"/> is <see langword="true"/>,
				 otherwise every other property will be included.
				 <br/>
				 Elements will be tracked if and only if <paramref name="isTracked"/> is <see langword="true"/>.
				 <br/>
				 If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				 a SQL command, the predicate will be ignored.
				 <br/>
				 See <see cref="GenericToolsQueriesAndLists.QueryTryPredicateWhere{T}(IQueryable{T}, Expression{Func{T, bool}})"/>
				 for more information.
			</summary>
			<param name="isIncludes">Will all other properties be included</param>
			<param name="isTracked">Will the element be tracked</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member> 
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.GetAllByIncludes(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements following condition <paramref name="predicateWhere"/>.
				<br/>
				Every other property will be included, elements will not be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.GetAllByIncludesTracked(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements following condition <paramref name="predicateWhere"/>.
				<br/>
				Every other property will be included, elements will be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.GetAllByExcludes(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements following condition <paramref name="predicateWhere"/>.
				<br/>
				Every other property will be excluded, elements will not be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.GetAllByExcludesTracked(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements following condition <paramref name="predicateWhere"/>.
				<br/>
				Every other property will be excluded, elements will be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.GetAll(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Linq.Expressions.Expression{System.Func{System.Linq.IQueryable{`0},System.Linq.IOrderedQueryable{`0}}},System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements ordered by <paramref name="orderreq"/> following condition <paramref name="predicateWhere"/>
				starting at index <paramref name="start"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be excluded if and only if <paramref name="isIncludes"/> is <see langword="true"/>,
				otherwise every other property will be included.
				<br/>
				Elements will be tracked if and only if <paramref name="isTracked"/> is <see langword="true"/>.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="isIncludes">Will all other properties be included</param>
			<param name="isTracked">Will the element be tracked</param>
			<param name="start">Starting index</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="orderreq">Order function</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.GetAllExcludes(System.Int32,System.Int32,System.Linq.Expressions.Expression{System.Func{System.Linq.IQueryable{`0},System.Linq.IOrderedQueryable{`0}}},System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements ordered by <paramref name="orderreq"/> following condition <paramref name="predicateWhere"/>
				starting at index <paramref name="start"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be excluded, elements will not be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="start">Starting index</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="orderreq">Order function</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.GetAllExcludesTracked(System.Int32,System.Int32,System.Linq.Expressions.Expression{System.Func{System.Linq.IQueryable{`0},System.Linq.IOrderedQueryable{`0}}},System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements ordered by <paramref name="orderreq"/> following condition <paramref name="predicateWhere"/>
				starting at index <paramref name="start"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be excluded, elements will be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="start">Starting index</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="orderreq">Order function</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.GetAllIncludes(System.Int32,System.Int32,System.Linq.Expressions.Expression{System.Func{System.Linq.IQueryable{`0},System.Linq.IOrderedQueryable{`0}}},System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements ordered by <paramref name="orderreq"/> following condition <paramref name="predicateWhere"/>
				starting at index <paramref name="start"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be included, elements will not be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="start">Starting index</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="orderreq">Order function</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.GetAllIncludesTracked(System.Int32,System.Int32,System.Linq.Expressions.Expression{System.Func{System.Linq.IQueryable{`0},System.Linq.IOrderedQueryable{`0}}},System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements ordered by <paramref name="orderreq"/> following condition <paramref name="predicateWhere"/>
				starting at index <paramref name="start"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be included, elements will be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="start">Starting index</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="orderreq">Order function</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.List(System.Boolean,System.Boolean)">
			<summary>
				Get the collection as a <see cref="T:System.Collections.Generic.List`1"/>. Specify if all other types in relationship with <typeparamref name="T"/>
				have to be included in the query, and if the elements have to be tracked.
			</summary>
			<param name="isIncludes">
				Whether or not other types in relationship with <typeparamref name="T"/>
				have to be included in the query
			</param>
			<param name="isTracked">Whether or not elements have to be tracked</param>
			<returns>The list</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.ListExcludes">
			<summary>
				Get the collection as a <see cref="T:System.Collections.Generic.List`1"/>, other types in relationship with <typeparamref name="T"/> excluded, elements not tracked.
			</summary>
			<returns>The list</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.ListExcludesTracked">
			<summary>
				Get the collection as a <see cref="T:System.Collections.Generic.List`1"/>, other types in relationship with <typeparamref name="T"/> excluded, elements tracked.
			</summary>
			<returns>The list</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.ListIncludes">
			<summary>
				Get the collection as a <see cref="T:System.Collections.Generic.List`1"/>, other types in relationship with <typeparamref name="T"/> included, elements not tracked.
			</summary>
			<returns>The list</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.ListIncludesTracked">
			<summary>
				Get the collection as a <see cref="T:System.Collections.Generic.List`1"/>, other types in relationship with <typeparamref name="T"/> included, elements tracked.
			</summary>
			<returns>The list</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.Modify(`0)">
			<summary>
				Modifies an element <paramref name="t"/> in DB of type <typeparamref name="T"/>
				<br/>
				Throws exception <see cref="T:GenericRepositoryAndService.Exceptions.CascadeCreationInDBException"/> if <typeparamref name="T"/> is in a relationship with a class in a <see cref="T:System.Data.Entity.DbSet"/> of <see cref="F:GenericRepositoryAndService.Repository.GenericRepository`1.DataContext"/>.
				These elements could be dublicated in DB otherwise, since they could be loaded in the context.
			</summary>
			<param name="t">Element to modify</param>
			<exception cref="T:GenericRepositoryAndService.Exceptions.CascadeCreationInDBException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.Remove(System.Object[])">
			<summary>
				Removes an object from DB (without committing) having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Id of the object to delete, or its keys values.</param>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.Remove(`0)">
			<summary>
				Removes a specific object <paramref name="t"/> of type <typeparamref name="T"/> from DB (without comitting)
			</summary>
			<param name="t">The object to delete</param>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.Save(`0,System.Object[])">
			<summary>
				Saves an element <paramref name="t"/> in DB of type <typeparamref name="T"/>.
				<br/>
				<remark>
					<paramref name="objs"/> are properties of <typeparamref name="T"/> in a relationship
					with <typeparamref name="T"/>.
				</remark>
				<br/>
				<remark>
					Objects not mentionned will be set to either <see langword="null"/> or <see langword="new"/> <c>List&lt;Class&gt;()</c>
				</remark>
				<br/>
				Objects in <paramref name="objs"/> with values <see langword="null"/> will be ignored.
				<br/>
				Order is not important, unless properties are of the same type. In that case, they will be assigned
				in the same order as they are declared in the class <typeparamref name="T"/>.
				<br/>
				Properties can be forced to either <see langword="null"/> or <see langword="new"/> <c>List&lt;Class&gt;()</c> by having the set in <paramref name="objs"/>
				as a type <see cref="T:GenericRepositoryAndService.Tools.Generic.PropToNull"/> with <see cref="P:GenericRepositoryAndService.Tools.Generic.PropToNull.PropertyName"/> set to the name
				of the property. Usefull if <typeparamref name="T"/> is in many relationships with the same type.
				See exemple for more information.
				<br/>
				<example>
					Exemple : assume T is a class deriving from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/> with properties
					<list type="bullet">
						<item>S propS</item>
						<item>Q propQ1</item>
						<item>Q propQ2</item>
						<item>R propR</item>
					</list>
					where Q,R and S are other types in DB. Say you want to setup the <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/> for the following values :
					<br/>
					propS = <see langword="null"/>, propQ1 = <see langword="null"/>, propQ2 = VARQ, propR = VARR. To do so, call :
					<code>
						Save(<see langword="new"/> PropToNull("propQ1"), VARQ , VARR)
					</code>
					Reason and purpose : <see langword="null"/> values are ignored (since they could be assigned to any DB
					type a priori, leading to ambiguity if some properties values are not specified)
					and in the case of many properties of the same type, the order set in the definition of the
					class <typeparamref name="T"/> has to be respected. Thus, doing either
					<c>
						Save(<see langword="null"/>, VARQ, VARR)
					</c> or <c>Save(VARQ, VARR)</c> would result in setting :
					<br/>
					propS = <see langword="null"/>, propQ1 = VARQ, propQ2 = <see langword="null"/>, propR = VARR
					<br/>
					which is not what was wanted. <see cref="T:GenericRepositoryAndService.Tools.Generic.PropToNull"/> is usefull only for that specific case.
				</example>
			</summary>
			<param name="t">The object to update</param>
			<param name="objs">
				Objects that are properties of the object <paramref name="t"/> and that
				are in relationship with the type <typeparamref name="T"/>.
				<br/>
				<remark>
					<paramref name="objs"/> are properties of <typeparamref name="T"/> in a relationship
					with <typeparamref name="T"/>.
				</remark>
				<br/>
				<remark>
					Objects not mentionned will be set to either <see langword="null"/> or <see langword="new"/> <c>List&lt;Class&gt;()</c>.
				</remark>
			</param>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidArgumentsForClassException"/>
			<exception cref="T:GenericRepositoryAndService.Exceptions.CascadeCreationInDBException" />
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.Update(`0,System.Object[])">
			<summary>
				Updates an element <paramref name="t"/> in DB of type <typeparamref name="T"/>.
				<br/>
				<remark>
					<paramref name="objs"/> are properties of <typeparamref name="T"/> in a relationship
					with <typeparamref name="T"/>.
				</remark>
				<br/>
				<remark>
					Objects not mentionned will be set to either <see langword="null"/> or <see langword="new"/> <c>List&lt;Class&gt;()</c>.
				</remark>
				<br/>
				Objects in <paramref name="objs"/> with values <see langword="null"/> will be ignored.
				<br/>
				Order is not important, unless properties are of the same type. In that case, they will be assigned
				in the same order as they are declared in the class <typeparamref name="T"/>.
				<br/>
				Properties can be forced to either <see langword="null"/> or <see langword="new"/> <c>List&lt;Class&gt;()</c> by having the set in <paramref name="objs"/>
				as a type <see cref="T:GenericRepositoryAndService.Tools.Generic.PropToNull"/> with <see cref="P:GenericRepositoryAndService.Tools.Generic.PropToNull.PropertyName"/> set to the name
				of the property. Usefull if <typeparamref name="T"/> is in many relationships with the same type.
				See exemple for more information.
				<br/>
				<example>
					Exemple : assume T is a class deriving from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/> with properties
					<list type="bullet">
						<item>S propS</item>
						<item>Q propQ1</item>
						<item>Q propQ2</item>
						<item>R propR</item>
					</list>
					where Q,R and S are other types in DB. Say you want to setup the <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/> for the following values :
					<br/>
					propS = <see langword="null"/>, propQ1 = <see langword="null"/>, propQ2 = VARQ, propR = VARR. To do so, call :
					<code>
						Update(<see langword="new"/> PropToNull("propQ1"), VARQ , VARR)
					</code>
					Reason and purpose : <see langword="null"/> values are ignored (since they could be assigned to any DB
					type a priori, leading to ambiguity if some properties values are not specified)
					and in the case of many properties of the same type, the order set in the definition of the
					class <typeparamref name="T"/> has to be respected. Thus, doing either
					<c>
						Update(<see langword="null"/>, VARQ, VARR)
					</c> or <c>Update(VARQ, VARR)</c> would result in setting :
					<br/>
					propS = <see langword="null"/>, propQ1 = VARQ, propQ2 = <see langword="null"/>, propR = VARR
					<br/>
					which is not what was wanted. <see cref="T:GenericRepositoryAndService.Tools.Generic.PropToNull"/> is usefull only for that specific case.
				</example>
			</summary>
			<param name="t">The object to update</param>
			<param name="objs">
				Objects that are properties of the object <paramref name="t"/> and that
				are in relationship with the type <typeparamref name="T"/>.
				<br/>
				<remark>
					<paramref name="objs"/> are properties of <typeparamref name="T"/> in a relationship
					with <typeparamref name="T"/>.
				</remark>
				<br/>
				<remark>
					Objects not mentionned will be set to either <see langword="null"/> or <see langword="new"/> <c>List&lt;Class&gt;()</c>.
				</remark>
			</param>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidArgumentsForClassException"/>
			<exception cref="T:GenericRepositoryAndService.Exceptions.CascadeCreationInDBException" />
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.CreateDefaultListCustomParamFromKey(System.String)">
			<summary>
				Create a <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/> with value <see langword="new"/> <c>List&lt;Class&gt;()</c> for the
				property with key <paramref name="key"/> in <see cref="F:GenericRepositoryAndService.Repository.GenericRepository`1._DynamicDBListTypes"/>
			</summary>
			<param name="key"></param>
			<returns>
				The new <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/>
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.CreateDefaultCustomParamFromKey(System.String)">
			<summary>
				Create a <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/> with value <see langword="null"/> for the
				property with key <paramref name="key"/> in <see cref="F:GenericRepositoryAndService.Repository.GenericRepository`1._DynamicDBTypes"/>
			</summary>
			<param name="key"></param>
			<returns>
				The new <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/>
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.CreateListCustomParamFromKey(System.String,System.Object)">
			<summary>
				Create a <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/> with value <paramref name="obj"/> for the
				property with key <paramref name="key"/> in <see cref="F:GenericRepositoryAndService.Repository.GenericRepository`1._DynamicDBListTypes"/>
			</summary>
			<param name="key"></param>
			<param name="obj"></param>
			<returns>
				The new <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/>
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.CreateCustomParamFromKey(System.String,System.Object)">
			<summary>
				Create a <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/> with value <paramref name="obj"/> for the
				property with key <paramref name="key"/> in <see cref="F:GenericRepositoryAndService.Repository.GenericRepository`1._DynamicDBTypes"/>
			</summary>
			<param name="key"></param>
			<param name="obj"></param>
			<returns>
				The new <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/>
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.SetCustom(System.Object[])">
			<summary>
				Setup for <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/>.
				<br/>
				If an object corresponding to a property representing a relationship involving <typeparamref name="T"/> is in <paramref name="objs"/>
				construct a new <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/> corresponding to that property.
				<br/>
				Once every <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/> is constructed, construct default param (with value either <see langword="null"/> or <see langword="new"/> <c>List&lt;Class&gt;()</c>)
				for every other property that was not included in <paramref name="objs"/>.
				<br/>
				Objects in <paramref name="objs"/> with values <see langword="null"/> will be ignored.
				<br/>
				Order is not important, unless properties are of the same type. In that case, they will be assigned
				in the same order as they are declared in the class <typeparamref name="T"/>.
				<br/>
				Properties can be forced to either <see langword="null"/> or <see langword="new"/> <c>List&lt;Class&gt;()</c> by having the set in <paramref name="objs"/>
				as a type <see cref="T:GenericRepositoryAndService.Tools.Generic.PropToNull"/> with <see cref="P:GenericRepositoryAndService.Tools.Generic.PropToNull.PropertyName"/> set to the name
				of the property. Usefull if <typeparamref name="T"/> is in many relationships with the same type.
				See exemple for more information.
				<br/>
				<example>
					Exemple : assume T is a class deriving from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/> with properties
					<list type="bullet">
						<item>S propS</item>
						<item>Q propQ1</item>
						<item>Q propQ2</item>
						<item>R propR</item>
					</list>
					where Q,R and S are other types in DB. Say you want to setup the <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/> for the following values :
					<br/>
					propS = <see langword="null"/>, propQ1 = <see langword="null"/>, propQ2 = VARQ, propR = VARR. To do so, call :
					<code>
						SetCustom(<see langword="new"/> PropToNull("propQ1"), VARQ , VARR)
					</code>
					Reason and purpose : <see langword="null"/> values are ignored (since they could be assigned to any DB
					type a priori, leading to ambiguity if some properties values are not specified)
					and in the case of many properties of the same type, the order set in the definition of the
					class <typeparamref name="T"/> has to be respected. Thus, doing either
					<c>
						SetCustom(<see langword="null"/>, VARQ, VARR)
					</c> or <c>SetCustom(VARQ, VARR)</c> would result in setting :
					<br/>
					propS = <see langword="null"/>, propQ1 = VARQ, propQ2 = <see langword="null"/>, propR = VARR
					<br/>
					which is not what was wanted. <see cref="T:GenericRepositoryAndService.Tools.Generic.PropToNull"/> is usefull only for that specific case.
				</example>
			</summary>
			<param name="objs">
				List of objets for which to set up <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/>
			</param>
			<returns>
				The complete list of <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/> with every property representing a
				relationship involving <typeparamref name="T"/> covered.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidArgumentsForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.SetNewParamFromContextList(System.Data.Entity.DbContext,GenericRepositoryAndService.Repository.GenericRepository{`0}.CustomParam)">
			<summary>
				Setup a new parameter <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/>. The only difference with <paramref name="customParam"/>
				is that the value is loaded from an other context <paramref name="newContext"/>
				<remark>
					The property is of type <see cref="T:System.Collections.IList"/>
				</remark>
			</summary>
			<param name="newContext">New context</param>
			<param name="customParam">Parameter from old context</param>
			<returns>
				The new parameter <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/> from context <paramref name="newContext"/>
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.SetNewParamFromContextNotList(System.Data.Entity.DbContext,GenericRepositoryAndService.Repository.GenericRepository{`0}.CustomParam)">
			<summary>
				Setup a new parameter <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/>. The only difference with <paramref name="customParam"/>
				is that the value is loaded from an other context <paramref name="newContext"/>
				<remark>
					The property is NOT of type <see cref="T:System.Collections.IList"/>
				</remark>
			</summary>
			<param name="newContext">New context</param>
			<param name="customParam">Parameter from old context</param>
			<returns>
				The new parameter <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/> from context <paramref name="newContext"/>
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>s
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.SetNewParamsFromContext(System.Data.Entity.DbContext,GenericRepositoryAndService.Repository.GenericRepository{`0}.CustomParam[])">
			<summary>
				SetUp new <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/> for properties representing relationships involving <typeparamref name="T"/> using the context <paramref name="newContext"/>.
				<br/>
				<remark>
					Assumes every property representing a relationships involving <typeparamref name="T"/> has a corresponding <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/> in <paramref name="props"/>
				</remark>
			</summary>
			<param name="newContext">Context</param>
			<param name="props">
				Initial <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/>
			</param>
			<returns>
				New <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/> from the context <paramref name="newContext"/>
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.ModifyOtherProperties(`0,`0,GenericRepositoryAndService.Repository.GenericRepository{`0}.CustomParam[])">
			<summary>
				Change every property (that does NOT represent a relationship involving <typeparamref name="T"/>) of <paramref name="t"/> with values from <paramref name="newt"/>
				<br/>
				<remark>
					Assumes every property representing a relationships involving <typeparamref name="T"/> has a corresponding <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/> in <paramref name="props"/>
				</remark>
			</summary>
			<param name="t">The object to modify</param>
			<param name="newt">The object to get values from</param>
			<param name="props">
				The <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/> representing properties representing relationships involving <typeparamref name="T"/>
			</param>
			<returns>
				The object <paramref name="t"/> with properties not representing relationships involving <typeparamref name="T"/> having values from <paramref name="newt"/>
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.SaveGeneric(`0,GenericRepositoryAndService.Repository.GenericRepository{`0}.CustomParam[])">
			<summary>
				Saves an object <paramref name="t"/> of class <typeparamref name="T"/> in DB.
				<br/>
				<remark>
					Assumes every property representing a relationships involving <typeparamref name="T"/> has a corresponding <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/> in <paramref name="propss"/>
				</remark>
			</summary>
			<param name="t">Object to update</param>
			<param name="propss">
				<see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/> for properties representing a relationship involving <typeparamref name="T"/>
				containing new values
			</param>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.FindByIdIncludesTrackedInNewContext(System.Data.Entity.DbContext,System.Object[])">
			<summary>
				See <see cref="M:GenericRepositoryAndService.Repository.GenericRepository`1.FindByIdIncludesTracked(System.Object[])"/>. Does the same thing in a specific context
				<paramref name="dbContext"/>, ie
				<br/>
				finds an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> included, elements tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="dbContext">The context from which the element has to be found</param>
			<param name="objs">Either the Id of the object to delete, or its keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.FindByIdIncludesInNewContext(System.Data.Entity.DbContext,System.Object[])">
			<summary>
				See <see cref="M:GenericRepositoryAndService.Repository.GenericRepository`1.FindByIdIncludes(System.Object[])"/>. Does the same thing in a specific context
				<paramref name="dbContext"/>, ie
				<br/>
				finds an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> included, elements not tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="dbContext">The context from which the element has to be found</param>
			<param name="objs">Either the Id of the object to delete, or its keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.UpdateGeneric(System.Data.Entity.DbContext,`0,GenericRepositoryAndService.Repository.GenericRepository{`0}.CustomParam[])">
			<summary>
				Updates an object <paramref name="t"/> of class <typeparamref name="T"/> in DB.
				<br/>
				<remark>
					Assumes every property representing a relationships involving <typeparamref name="T"/> has a corresponding <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/> in <paramref name="propss"/>
				</remark>
			</summary>
			<param name="context">The context</param>
			<param name="t">Object to update</param>
			<param name="propss">
				<see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1.CustomParam"/> for properties representing a relationship involving <typeparamref name="T"/>
				containing new values
			</param>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.GenericRepository`1.UpdateOne(`0,System.String,System.Object)">
			<summary>
				Updates one specific property with name <paramref name="propertyName"/> with the value
				<paramref name="newValue"/> for an object <paramref name="t"/> of class <typeparamref name="T"/> in DB.
			</summary>
			<param name="t">Object to update</param>
			<param name="propertyName">The name of the property to update</param>
			<param name="newValue">The new value</param>
			<exception cref="T:GenericRepositoryAndService.Exceptions.PropertyNameNotFoundException"/>
			<exception cref="T:GenericRepositoryAndService.Exceptions.CannotWriteReadOnlyPropertyException"/>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidArgumentsForClassException"/>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="T:GenericRepositoryAndService.Repository.IGenericRepository`1">
			<summary>
				Generic Repository interface for class <typeparamref name="T"/> using context
				type <see cref="T:System.Data.Entity.DbContext"/>.
				<remark>
					Assumes every class that either derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					or has at least one property with annotation <see cref="T:System.ComponentModel.DataAnnotations.KeyAttribute"/>
					has a <see cref="T:System.Data.Entity.DbSet"/> in <see cref="T:System.Data.Entity.DbContext"/>.
					<br/>
					And that reciprocally, every class having a <see cref="T:System.Data.Entity.DbSet"/> in
					<see cref="T:System.Data.Entity.DbContext"/> either derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					or has at least one property with annotation <see cref="T:System.ComponentModel.DataAnnotations.KeyAttribute"/>.
					<br/>
					Any other implementation of this interface than <see cref="T:GenericRepositoryAndService.Repository.GenericRepository`1"/>
					must have a property of type <see cref="T:System.Data.Entity.DbContext"/>
					named "temprep.DataContext" accessible from this dll (i.e. public) so that
					GenericService will work.
				</remark>
			</summary>
			<typeparam name="T"></typeparam>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.Add(`0)">
			<summary>
				Adds an element <paramref name="t"/> in DB of type <typeparamref name="T"/>
				<br/>
				Throws exception <see cref="T:GenericRepositoryAndService.Exceptions.CascadeCreationInDBException"/> if <typeparamref name="T"/> is in a relationship with a class in a <see cref="T:System.Data.Entity.DbSet"/> of <see cref="!:DataContext"/>.
				These elements could be dublicated in DB otherwise, they could be loaded in the context.
			</summary>
			<param name="t">Element to add</param>
			<exception cref="T:GenericRepositoryAndService.Exceptions.CascadeCreationInDBException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.Collection(System.Boolean,System.Boolean)">
			<summary>
				Get the IQueryable collection. Specify if all other types in relationship with <typeparamref name="T"/>
				have to be included in the query, and if the elements have to be tracked.
			</summary>
			<param name="isIncludes">
				Whether or not other types in relationship with <typeparamref name="T"/>
				have to be included in the query
			</param>
			<param name="isTracked">Whether or not elements have to be tracked</param>
			<returns>The IQueryable collection</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.CollectionExcludes">
			<summary>
				Get the IQueryable collection, other types in relationship with <typeparamref name="T"/> excluded, elements not tracked.
			</summary>
			<returns>The query</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.CollectionExcludesTracked">
			<summary>
				Get the IQueryable collection, other types in relationship with <typeparamref name="T"/> excluded, elements tracked.
			</summary>
			<returns>The query</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.CollectionIncludes">
			<summary>
				Get the IQueryable collection, other types in relationship with <typeparamref name="T"/> included, elements not tracked.
			</summary>
			<returns>The query</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.CollectionIncludesTracked">
			<summary>
				Get the IQueryable collection, other types in relationship with <typeparamref name="T"/> included, elements tracked.
			</summary>
			<returns>The query</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.Commit">
			<summary>
				Commit the changes in DB
			</summary>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.Count(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Counts the elements in DB for which the predicate <paramref name="predicateWhere"/> is <see langword="true"/>.
			</summary>
			<remarks>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</remarks>
			<param name="predicateWhere"></param>
			<returns>
				The number of elements in DB satisfying <paramref name="predicateWhere"/>
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.Delete(System.Object[])">
			<summary>
				Deletes an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Id of the object to delete, or its keys values.</param>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.Delete(`0)">
			<summary>
				Deletes a specific object <paramref name="t"/> of type <typeparamref name="T"/> from DB
			</summary>
			<param name="t">The object to delete</param>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.FindById(System.Boolean,System.Boolean,System.Object[])">
			<summary>
				Finds an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
				Specify if all other types in relationship with <typeparamref name="T"/>
				have to be included in the query, and if the elements have to be tracked
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="isIncludes">
				Whether or not other types in relationship with <typeparamref name="T"/>
				have to be included in the query
			</param>
			<param name="isTracked">Whether or not elements have to be tracked</param>
			<param name="objs">Either the Id of the object to find, or its keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.FindByIdExcludes(System.Object[])">
			<summary>
				Finds an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> excluded, elements not tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Id of the object to find, or its keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.FindByIdExcludesTracked(System.Object[])">
			<summary>
				Finds an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> excluded, elements tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Id of the object to find, or its keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.FindByIdIncludes(System.Object[])">
			<summary>
				Finds an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> included, elements not tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Id of the object to find, or its keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.FindByIdIncludesTracked(System.Object[])">
			<summary>
				Finds an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> included, elements tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Id of the object to find, or its keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.GetAll(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Linq.Expressions.Expression{System.Func{System.Linq.IQueryable{`0},System.Linq.IOrderedQueryable{`0}}},System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements ordered by <paramref name="orderreq"/> following condition <paramref name="predicateWhere"/>
				starting at index <paramref name="start"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be excluded if and only if <paramref name="isIncludes"/> is <see langword="true"/>,
				otherwise every other property will be included.
				<br/>
				Elements will be tracked if and only if <paramref name="isTracked"/> is <see langword="true"/>.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="isIncludes">Will all other properties be included</param>
			<param name="isTracked">Will the element be tracked</param>
			<param name="start">Starting index</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="orderreq">Order function</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name ="M:GenericRepositoryAndService.Repository.IGenericRepository`1.GetAllBy(System.Boolean,System.Boolean,System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements following condition <paramref name="predicateWhere"/>.
				<br/>
				Every other property will be excluded if and only if <paramref name="isIncludes"/> is <see langword="true"/>,
				otherwise every other property will be included.
				<br/>
				Elements will be tracked if and only if <paramref name="isTracked"/> is <see langword="true"/>.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="GenericToolsQueriesAndLists.QueryTryPredicateWhere{T}(IQueryable{T}, Expression{Func{T, bool}})"/>
				for more information.
			</summary>
			<param name="isIncludes">Will all other properties be included</param>
			<param name="isTracked">Will the element be tracked</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.GetAllByExcludes(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements following condition <paramref name="predicateWhere"/>.
				<br/>
				Every other property will be excluded, elements will not be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.GetAllByExcludesTracked(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements following condition <paramref name="predicateWhere"/>.
				<br/>
				Every other property will be excluded, elements will be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.GetAllByIncludes(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements following condition <paramref name="predicateWhere"/>.
				<br/>
				Every other property will be included, elements will not be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.GetAllByIncludesTracked(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements following condition <paramref name="predicateWhere"/>.
				<br/>
				Every other property will be included, elements will be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.GetAllExcludes(System.Int32,System.Int32,System.Linq.Expressions.Expression{System.Func{System.Linq.IQueryable{`0},System.Linq.IOrderedQueryable{`0}}},System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements ordered by <paramref name="orderreq"/> following condition <paramref name="predicateWhere"/>
				starting at index <paramref name="start"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be excluded, elements will not be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="start">Starting index</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="orderreq">Order function</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.GetAllExcludesTracked(System.Int32,System.Int32,System.Linq.Expressions.Expression{System.Func{System.Linq.IQueryable{`0},System.Linq.IOrderedQueryable{`0}}},System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements ordered by <paramref name="orderreq"/> following condition <paramref name="predicateWhere"/>
				starting at index <paramref name="start"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be excluded, elements will be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="start">Starting index</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="orderreq">Order function</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.GetAllIncludes(System.Int32,System.Int32,System.Linq.Expressions.Expression{System.Func{System.Linq.IQueryable{`0},System.Linq.IOrderedQueryable{`0}}},System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements ordered by <paramref name="orderreq"/> following condition <paramref name="predicateWhere"/>
				starting at index <paramref name="start"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be included, elements will not be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="start">Starting index</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="orderreq">Order function</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.GetAllIncludesTracked(System.Int32,System.Int32,System.Linq.Expressions.Expression{System.Func{System.Linq.IQueryable{`0},System.Linq.IOrderedQueryable{`0}}},System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements ordered by <paramref name="orderreq"/> following condition <paramref name="predicateWhere"/>
				starting at index <paramref name="start"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be included, elements will be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="start">Starting index</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="orderreq">Order function</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.List(System.Boolean,System.Boolean)">
			<summary>
				Get the collection as a <see cref="T:System.Collections.Generic.List`1"/>. Specify if all other types in relationship with <typeparamref name="T"/>
				have to be included in the query, and if the elements have to be tracked.
			</summary>
			<param name="isIncludes">
				Whether or not other types in relationship with <typeparamref name="T"/>
				have to be included in the query
			</param>
			<param name="isTracked">Whether or not elements have to be tracked</param>
			<returns>The list</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.ListExcludes">
			<summary>
				Get the collection as a <see cref="T:System.Collections.Generic.List`1"/>, other types in relationship with <typeparamref name="T"/> excluded, elements not tracked.
			</summary>
			<returns>The list</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.ListExcludesTracked">
			<summary>
				Get the collection as a <see cref="T:System.Collections.Generic.List`1"/>, other types in relationship with <typeparamref name="T"/> excluded, elements tracked.
			</summary>
			<returns>The list</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.ListIncludes">
			<summary>
				Get the collection as a <see cref="T:System.Collections.Generic.List`1"/>, other types in relationship with <typeparamref name="T"/> included, elements not tracked.
			</summary>
			<returns>The list</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.ListIncludesTracked">
			<summary>
				Get the collection as a <see cref="T:System.Collections.Generic.List`1"/>, other types in relationship with <typeparamref name="T"/> included, elements tracked.
			</summary>
			<returns>The list</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.Modify(`0)">
			<summary>
				Modifies an element <paramref name="t"/> in DB of type <typeparamref name="T"/>
				<br/>
				Throws exception <see cref="T:GenericRepositoryAndService.Exceptions.CascadeCreationInDBException"/> if <typeparamref name="T"/> is in a relationship with a class in a <see cref="T:System.Data.Entity.DbSet"/> of <see cref="!:DataContext"/>.
				These elements could be dublicated in DB otherwise, since they could be loaded in the context.
			</summary>
			<param name="t">Element to modify</param>
			<exception cref="T:GenericRepositoryAndService.Exceptions.CascadeCreationInDBException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.Remove(System.Object[])">
			<summary>
				Removes an object from DB (without committing) having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Id of the object to delete, or its keys values.</param>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.Remove(`0)">
			<summary>
				Removes a specific object <paramref name="t"/> of type <typeparamref name="T"/> from DB (without comitting)
			</summary>
			<param name="t">The object to delete</param>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.Save(`0,System.Object[])">
			<summary>
				Saves an element <paramref name="t"/> in DB of type <typeparamref name="T"/>.
				<br/>
				<remark>
					<paramref name="objs"/> are properties of <typeparamref name="T"/> in a relationship
					with <typeparamref name="T"/>.
				</remark>
				<br/>
				<remark>
					Objects not mentionned will be set to either <see langword="null"/> or <see langword="new"/> <c>List&lt;Class&gt;()</c>
				</remark>
				<br/>
				Objects in <paramref name="objs"/> with values <see langword="null"/> will be ignored.
				<br/>
				Order is not important, unless properties are of the same type. In that case, they will be assigned
				in the same order as they are declared in the class <typeparamref name="T"/>.
				<br/>
				Properties can be forced to either <see langword="null"/> or <see langword="new"/> <c>List&lt;Class&gt;()</c> by having the set in <paramref name="objs"/>
				as a type <see cref="T:GenericRepositoryAndService.Tools.Generic.PropToNull"/> with <see cref="P:GenericRepositoryAndService.Tools.Generic.PropToNull.PropertyName"/> set to the name
				of the property. Usefull if <typeparamref name="T"/> is in many relationships with the same type.
				See exemple for more information.
				<br/>
				<example>
					Exemple : assume T is a class deriving from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/> with properties
					<list type="bullet">
						<item>S propS</item>
						<item>Q propQ1</item>
						<item>Q propQ2</item>
						<item>R propR</item>
					</list>
					where Q,R and S are other types in DB. Say you want to setup the <see cref="!:CustomParam"/> for the following values :
					<br/>
					propS = <see langword="null"/>, propQ1 = <see langword="null"/>, propQ2 = VARQ, propR = VARR. To do so, call :
					<code>
						Save(<see langword="new"/> PropToNull("propQ1"), VARQ , VARR)
					</code>
					Reason and purpose : <see langword="null"/> values are ignored (since they could be assigned to any DB
					type a priori, leading to ambiguity if some properties values are not specified)
					and in the case of many properties of the same type, the order set in the definition of the
					class <typeparamref name="T"/> has to be respected. Thus, doing either
					<c>
						Save(<see langword="null"/>, VARQ, VARR)
					</c> or <c>Save(VARQ, VARR)</c> would result in setting :
					<br/>
					propS = <see langword="null"/>, propQ1 = VARQ, propQ2 = <see langword="null"/>, propR = VARR
					<br/>
					which is not what was wanted. <see cref="T:GenericRepositoryAndService.Tools.Generic.PropToNull"/> is usefull only for that specific case.
				</example>
			</summary>
			<param name="t">The object to update</param>
			<param name="objs">
				Objects that are properties of the object <paramref name="t"/> and that
				are in relationship with the type <typeparamref name="T"/>.
				<br/>
				<remark>
					<paramref name="objs"/> are properties of <typeparamref name="T"/> in a relationship
					with <typeparamref name="T"/>.
				</remark>
				<br/>
				<remark>
					Objects not mentionned will be set to either <see langword="null"/> or <see langword="new"/> <c>List&lt;Class&gt;()</c>.
				</remark>
			</param>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidArgumentsForClassException"/>
			<exception cref="T:GenericRepositoryAndService.Exceptions.CascadeCreationInDBException" />
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.Update(`0,System.Object[])">
			<summary>
				Updates an element <paramref name="t"/> in DB of type <typeparamref name="T"/>.
				<br/>
				<remark>
					<paramref name="objs"/> are properties of <typeparamref name="T"/> in a relationship
					with <typeparamref name="T"/>.
				</remark>
				<br/>
				<remark>
					Objects not mentionned will be set to either <see langword="null"/> or <see langword="new"/> <c>List&lt;Class&gt;()</c>.
				</remark>
				<br/>
				Objects in <paramref name="objs"/> with values <see langword="null"/> will be ignored.
				<br/>
				Order is not important, unless properties are of the same type. In that case, they will be assigned
				in the same order as they are declared in the class <typeparamref name="T"/>.
				<br/>
				Properties can be forced to either <see langword="null"/> or <see langword="new"/> <c>List&lt;Class&gt;()</c> by having the set in <paramref name="objs"/>
				as a type <see cref="T:GenericRepositoryAndService.Tools.Generic.PropToNull"/> with <see cref="P:GenericRepositoryAndService.Tools.Generic.PropToNull.PropertyName"/> set to the name
				of the property. Usefull if <typeparamref name="T"/> is in many relationships with the same type.
				See exemple for more information.
				<br/>
				<example>
					Exemple : assume T is a class deriving from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/> with properties
					<list type="bullet">
						<item>S propS</item>
						<item>Q propQ1</item>
						<item>Q propQ2</item>
						<item>R propR</item>
					</list>
					where Q,R and S are other types in DB. Say you want to setup the <see cref="!:CustomParam"/> for the following values :
					<br/>
					propS = <see langword="null"/>, propQ1 = <see langword="null"/>, propQ2 = VARQ, propR = VARR. To do so, call :
					<code>
						Update(<see langword="new"/> PropToNull("propQ1"), VARQ , VARR)
					</code>
					Reason and purpose : <see langword="null"/> values are ignored (since they could be assigned to any DB
					type a priori, leading to ambiguity if some properties values are not specified)
					and in the case of many properties of the same type, the order set in the definition of the
					class <typeparamref name="T"/> has to be respected. Thus, doing either
					<c>
						Update(<see langword="null"/>, VARQ, VARR)
					</c> or <c>Update(VARQ, VARR)</c> would result in setting :
					<br/>
					propS = <see langword="null"/>, propQ1 = VARQ, propQ2 = <see langword="null"/>, propR = VARR
					<br/>
					which is not what was wanted. <see cref="T:GenericRepositoryAndService.Tools.Generic.PropToNull"/> is usefull only for that specific case.
				</example>
			</summary>
			<param name="t">The object to update</param>
			<param name="objs">
				Objects that are properties of the object <paramref name="t"/> and that
				are in relationship with the type <typeparamref name="T"/>.
				<br/>
				<remark>
					<paramref name="objs"/> are properties of <typeparamref name="T"/> in a relationship
					with <typeparamref name="T"/>.
				</remark>
				<br/>
				<remark>
					Objects not mentionned will be set to either <see langword="null"/> or <see langword="new"/> <c>List&lt;Class&gt;()</c>.
				</remark>
			</param>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidArgumentsForClassException"/>
			<exception cref="T:GenericRepositoryAndService.Exceptions.CascadeCreationInDBException" />
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Repository.IGenericRepository`1.UpdateOne(`0,System.String,System.Object)">
			<summary>
				Updates one specific property with name <paramref name="propertyName"/> with the value
				<paramref name="newValue"/> for an object <paramref name="t"/> of class <typeparamref name="T"/> in DB.
			</summary>
			<param name="t">Object to update</param>
			<param name="propertyName">The name of the property to update</param>
			<param name="newValue">The new value</param>
			<exception cref="T:GenericRepositoryAndService.Exceptions.PropertyNameNotFoundException"/>
			<exception cref="T:GenericRepositoryAndService.Exceptions.CannotWriteReadOnlyPropertyException"/>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidArgumentsForClassException"/>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="T:GenericRepositoryAndService.Service.GenericService`1">
			<summary>
				Generic Repository for class <typeparamref name="T"/> using context
				type <see cref="!:DbContext"/>.
				<remark>
					Assumes that :
					<list type="bullet">
						<item>
							every class that either derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
							or has at least one property with annotation <see cref="T:System.ComponentModel.DataAnnotations.KeyAttribute"/>
							has a <see cref="!:DbSet"/> in <see cref="!:DbContext"/>
						</item>
						<item>
							and that reciprocally, every class having a <see cref="!:DbSet"/> in
							<see cref="!:DbContext"/> either derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
							or has at least one property with annotation <see cref="T:System.ComponentModel.DataAnnotations.KeyAttribute"/>.
						</item>
					</list>
					Furthermore, assumes that
					<list type="bullet">
						<item>
							For a class t with name "TName", the corresponding repository is named "TNameRepository"
						</item>
						<item>
							For a class t with name "TName", the corresponding service is named "TNameService"
						</item>
					</list>
				</remark>
			</summary>
			<typeparam name="T"></typeparam>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.Collection(System.Boolean,System.Boolean)">
			<summary>
				Get the IQueryable collection. Specify if all other types in relationship with <typeparamref name="T"/>
				have to be included in the query, and if the elements have to be tracked.
			</summary>
			<param name="isIncludes">
				Whether or not other types in relationship with <typeparamref name="T"/>
				have to be included in the query
			</param>
			<param name="isTracked">Whether or not elements have to be tracked</param>
			<returns>The IQueryable collection</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.CollectionExcludes">
			<summary>
				Get the IQueryable collection, other types in relationship with <typeparamref name="T"/> excluded, elements not tracked.
			</summary>
			<returns>The query</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.CollectionExcludesTracked">
			<summary>
				Get the IQueryable collection, other types in relationship with <typeparamref name="T"/> excluded, elements tracked.
			</summary>
			<returns>The query</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.CollectionIncludes">
			<summary>
				Get the IQueryable collection, other types in relationship with <typeparamref name="T"/> included, elements not tracked.
			</summary>
			<returns>The query</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.CollectionIncludesTracked">
			<summary>
				Get the IQueryable collection, other types in relationship with <typeparamref name="T"/> included, elements tracked.
			</summary>
			<returns>The query</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.Count(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Counts the elements in DB for which the predicate <paramref name="predicateWhere"/> is <see langword="true"/>.
			</summary>
			<remarks>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</remarks>
			<param name="predicateWhere"></param>
			<returns>
				The number of elements in DB satisfying <paramref name="predicateWhere"/>
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.FindAll(System.Boolean,System.Boolean,System.Int32,System.Int32,System.String)">
			<summary>
				Get a list of elements ordered by <see cref="M:GenericRepositoryAndService.Service.GenericService`1.OrderExpression"/> following condition
				<see cref="M:GenericRepositoryAndService.Service.GenericService`1.SearchExpression(System.String)"/> applied to <paramref name="searchField"/>
				for page <paramref name="page"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be excluded if and only if <paramref name="isIncludes"/> is <see langword="true"/>,
				otherwise every other property will be included.
				<br/>
				Elements will be tracked if and only if <paramref name="isTracked"/> is <see langword="true"/>.
				<br/>
				If <see cref="M:GenericRepositoryAndService.Service.GenericService`1.OrderExpression"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="isIncludes">Will all other properties be included</param>
			<param name="isTracked">Will the element be tracked</param>
			<param name="page">The page</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="searchField">The string with the search</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.FindAllExcludes(System.Int32,System.Int32,System.String)">
			<summary>
				Get a list of elements ordered by <see cref="M:GenericRepositoryAndService.Service.GenericService`1.OrderExpression"/> following condition
				<see cref="M:GenericRepositoryAndService.Service.GenericService`1.SearchExpression(System.String)"/> applied to <paramref name="searchField"/>
				for page <paramref name="page"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be excluded, elements will not be tracked.
				<br/>
				If <see cref="M:GenericRepositoryAndService.Service.GenericService`1.OrderExpression"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="page">The page</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="searchField">The string with the search</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.FindAllExcludesTracked(System.Int32,System.Int32,System.String)">
			<summary>
				Get a list of elements ordered by <see cref="M:GenericRepositoryAndService.Service.GenericService`1.OrderExpression"/> following condition
				<see cref="M:GenericRepositoryAndService.Service.GenericService`1.SearchExpression(System.String)"/> applied to <paramref name="searchField"/>
				for page <paramref name="page"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be excluded, elements will be tracked.
				<br/>
				If <see cref="M:GenericRepositoryAndService.Service.GenericService`1.OrderExpression"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="page">The page</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="searchField">The string with the search</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.FindAllIncludes(System.Int32,System.Int32,System.String)">
			<summary>
				Get a list of elements ordered by <see cref="M:GenericRepositoryAndService.Service.GenericService`1.OrderExpression"/> following condition
				<see cref="M:GenericRepositoryAndService.Service.GenericService`1.SearchExpression(System.String)"/> applied to <paramref name="searchField"/>
				for page <paramref name="page"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be included, elements will not be tracked.
				<br/>
				If <see cref="M:GenericRepositoryAndService.Service.GenericService`1.OrderExpression"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="page">The page</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="searchField">The string with the search</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.FindAllIncludesTracked(System.Int32,System.Int32,System.String)">
			<summary>
				Get a list of elements ordered by <see cref="M:GenericRepositoryAndService.Service.GenericService`1.OrderExpression"/> following condition
				<see cref="M:GenericRepositoryAndService.Service.GenericService`1.SearchExpression(System.String)"/> applied to <paramref name="searchField"/>
				for page <paramref name="page"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be included, elements will be tracked.
				<br/>
				If <see cref="M:GenericRepositoryAndService.Service.GenericService`1.OrderExpression"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="page">The page</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="searchField">The string with the search</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.FindById(System.Boolean,System.Boolean,System.Object[])">
			<summary>
				Finds an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
				Specify if all other types in relationship with <typeparamref name="T"/>
				have to be included in the query, and if the elements have to be tracked
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="isIncludes">
				Whether or not other types in relationship with <typeparamref name="T"/>
				have to be included in the query
			</param>
			<param name="isTracked">Whether or not elements have to be tracked</param>
			<param name="objs">Either the Id of the object to find, or its keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.FindByIdExcludes(System.Object[])">
			<summary>
				Finds an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> excluded, elements not tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Id of the object to find, or its keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.FindByIdExcludesTracked(System.Object[])">
			<summary>
				Finds an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> excluded, elements tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Id of the object to find, or its keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.FindByIdIncludes(System.Object[])">
			<summary>
				Finds an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> included, elements not tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Id of the object to find, or its keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.FindByIdIncludesTracked(System.Object[])">
			<summary>
				Finds an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> included, elements tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Id of the object to find, or its keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.FindByManyId(System.Boolean,System.Boolean,System.Object[])">
			<summary>
				Finds a list of objects from DB having
				<list type="bullet">
					<item>
						either specific Ids, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or specific key values otherwise, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.EntityWithKeys"/>.
					</item>
				</list>
				Specify if all other types in relationship with <typeparamref name="T"/>
				have to be included in the query, and if the elements have to be tracked
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="isIncludes">
				Whether or not other types in relationship with <typeparamref name="T"/>
				have to be included in the query
			</param>
			<param name="isTracked">Whether or not elements have to be tracked</param>
			<param name="objs">Either the Id of the object to delete, or its keys values.</param>
			<returns>The list of elements.</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.FindManyByIdExcludes(System.Object[])">
			<summary>
				Finds a list of objects from DB having
				<list type="bullet">
					<item>
						either specific Ids, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or specific key values otherwise, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.EntityWithKeys"/>.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> excluded, elements not tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Ids of the object to find, or their keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.FindManyByIdExcludesTracked(System.Object[])">
			<summary>
				Finds a list of objects from DB having
				<list type="bullet">
					<item>
						either specific Ids, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or specific key values otherwise, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.EntityWithKeys"/>.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> excluded, elements tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Ids of the object to find, or their keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.FindManyByIdIncludes(System.Object[])">
			<summary>
				Finds a list of objects from DB having
				<list type="bullet">
					<item>
						either specific Ids, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or specific key values otherwise, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.EntityWithKeys"/>.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> included, elements not tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Ids of the object to find, or their keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.FindManyByIdIncludesTracked(System.Object[])">
			<summary>
				Finds a list of objects from DB having
				<list type="bullet">
					<item>
						either specific Ids, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or specific key values otherwise, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.EntityWithKeys"/>.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> included, elements tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Ids of the object to find, or their keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.GetAllBy(System.Boolean,System.Boolean,System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements following condition <paramref name="predicateWhere"/>.
				<br/>
				Every other property will be excluded if and only if <paramref name="isIncludes"/> is <see langword="true"/>,
				otherwise every other property will be included.
				<br/>
				Elements will be tracked if and only if <paramref name="isTracked"/> is <see langword="true"/>.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="GenericToolsQueriesAndLists.QueryTryPredicateWhere{T}(IQueryable{T}, Expression{Func{T, bool}})"/>
				for more information.
				
			</summary>
			<param name="isIncludes">Will all other properties be included</param>
			<param name="isTracked">Will the element be tracked</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.GetAllByExcludes(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements following condition <paramref name="predicateWhere"/>.
				<br/>
				Every other property will be excluded, elements will not be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.GetAllByExcludesTracked(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements following condition <paramref name="predicateWhere"/>.
				<br/>
				Every other property will be excluded, elements will be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.GetAllByIncludes(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements following condition <paramref name="predicateWhere"/>.
				<br/>
				Every other property will be included, elements will not be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.GetAllByIncludesTracked(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements following condition <paramref name="predicateWhere"/>.
				<br/>
				Every other property will be included, elements will be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.GetAll(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Linq.Expressions.Expression{System.Func{System.Linq.IQueryable{`0},System.Linq.IOrderedQueryable{`0}}},System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements ordered by <paramref name="orderreq"/> following condition <paramref name="predicateWhere"/>
				for page <paramref name="page"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be excluded if and only if <paramref name="isIncludes"/> is <see langword="true"/>,
				otherwise every other property will be included.
				<br/>
				Elements will be tracked if and only if <paramref name="isTracked"/> is <see langword="true"/>.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="isIncludes">Will all other properties be included</param>
			<param name="isTracked">Will the element be tracked</param>
			<param name="page">The page</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="orderreq">Order function</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.GetAllExcludes(System.Int32,System.Int32,System.Linq.Expressions.Expression{System.Func{System.Linq.IQueryable{`0},System.Linq.IOrderedQueryable{`0}}},System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements ordered by <paramref name="orderreq"/> following condition <paramref name="predicateWhere"/>
				for page <paramref name="page"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be excluded, elements will not be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="page">The page</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="orderreq">Order function</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.GetAllExcludesTracked(System.Int32,System.Int32,System.Linq.Expressions.Expression{System.Func{System.Linq.IQueryable{`0},System.Linq.IOrderedQueryable{`0}}},System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements ordered by <paramref name="orderreq"/> following condition <paramref name="predicateWhere"/>
				for page <paramref name="page"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be excluded, elements will be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="page">The page</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="orderreq">Order function</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.GetAllIncludes(System.Int32,System.Int32,System.Linq.Expressions.Expression{System.Func{System.Linq.IQueryable{`0},System.Linq.IOrderedQueryable{`0}}},System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements ordered by <paramref name="orderreq"/> following condition <paramref name="predicateWhere"/>
				for page <paramref name="page"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be included, elements will not be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="page">The page</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="orderreq">Order function</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.GetAllIncludesTracked(System.Int32,System.Int32,System.Linq.Expressions.Expression{System.Func{System.Linq.IQueryable{`0},System.Linq.IOrderedQueryable{`0}}},System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements ordered by <paramref name="orderreq"/> following condition <paramref name="predicateWhere"/>
				for page <paramref name="page"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be included, elements will be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="page">The page</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="orderreq">Order function</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.List(System.Boolean,System.Boolean)">
			<summary>
				Get the collection as a <see cref="T:System.Collections.Generic.List`1"/>. Specify if all other types in relationship with <typeparamref name="T"/>
				have to be included in the query, and if the elements have to be tracked.
			</summary>
			<param name="isIncludes">
				Whether or not other types in relationship with <typeparamref name="T"/>
				have to be included in the query
			</param>
			<param name="isTracked">Whether or not elements have to be tracked</param>
			<returns>The list</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.ListExcludes">
			<summary>
				Get the collection as a <see cref="T:System.Collections.Generic.List`1"/>, other types in relationship with <typeparamref name="T"/> excluded, elements not tracked.
			</summary>
			<returns>The list</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.ListExcludesTracked">
			<summary>
				Get the collection as a <see cref="T:System.Collections.Generic.List`1"/>, other types in relationship with <typeparamref name="T"/> excluded, elements tracked.
			</summary>
			<returns>The list</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.ListIncludes">
			<summary>
				Get the collection as a <see cref="T:System.Collections.Generic.List`1"/>, other types in relationship with <typeparamref name="T"/> included, elements not tracked.
			</summary>
			<returns>The list</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.ListIncludesTracked">
			<summary>
				Get the collection as a <see cref="T:System.Collections.Generic.List`1"/>, other types in relationship with <typeparamref name="T"/> included, elements tracked.
			</summary>
			<returns>The list</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.NextExist(System.Int32,System.Int32,System.String)">
			<summary>
				Checks whether or not there is another page after <paramref name="page"/>
				for the search using <see cref="M:GenericRepositoryAndService.Service.GenericService`1.SearchExpression(System.String)"/> having <paramref name="maxByPage"/>
				elements per page.
			</summary>
			<param name="page">The current page number.</param>
			<param name="maxByPage">The maximum number of elements per page.</param>
			<param name="searchField">The string searched.</param>
			<returns>
				Whether or not there is another page after page number <paramref name="page"/>
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.OrderExpression">
			<summary>
				The expression with which the elements will be ordered when using <see cref="M:GenericRepositoryAndService.Service.GenericService`1.FindAll(System.Boolean,System.Boolean,System.Int32,System.Int32,System.String)"/>.
			</summary>
			<returns>The expression.</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.SearchExpression(System.String)">
			<summary>
				The expression used to search the elements in <see cref="M:GenericRepositoryAndService.Service.GenericService`1.FindAll(System.Boolean,System.Boolean,System.Int32,System.Int32,System.String)"/> and
				<see cref="M:GenericRepositoryAndService.Service.GenericService`1.NextExist(System.Int32,System.Int32,System.String)"/>.
				<br/>
				If <see cref="M:GenericRepositoryAndService.Service.GenericService`1.OrderExpression"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="searchField"></param>
			<returns></returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.Delete(System.Object[])">
			<summary>
				Deletes the element with either Id or keys <paramref name="objs"/>.
			</summary>
			<param name="objs">Either the Id or keys</param>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.Delete(`0)">
			<summary>
				Deletes the element <paramref name="t"/>
			</summary>
			<param name="t">The element to delete</param>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.Save(`0)">
			<summary>
				Saves the element <paramref name="t"/>.
			</summary>
			<param name="t">The element to save</param>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.SaveCrypted(`0)">
			<summary>
				Saves the elements <paramref name="t"/> after having crypted using
				<see cref="M:GenericRepositoryAndService.Tools.HashTools.ComputeSha256Hash(System.String)"/> every string property with annotation
				<see cref="T:System.ComponentModel.DataAnnotations.DataTypeAttribute"/> with type <see cref="F:System.ComponentModel.DataAnnotations.DataType.Password"/>.
			</summary>
			<param name="t">The element to crypt then save.</param>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.Update(`0)">
			<summary>
				Updates an element <paramref name="t"/>
			</summary>
			<param name="t">The element to update</param>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.UpdateCrypted(`0)">
			<summary>
				Updates the element <paramref name="t"/> after having crypted using
				<see cref="M:GenericRepositoryAndService.Tools.HashTools.ComputeSha256Hash(System.String)"/> every string property with annotation
				<see cref="T:System.ComponentModel.DataAnnotations.DataTypeAttribute"/> with type <see cref="F:System.ComponentModel.DataAnnotations.DataType.Password"/> that have changed.
			</summary>
			<param name="t">The object to update.</param>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.UpdateOne(`0,System.String,System.Object)">
			<summary>
				Update only the property with name <paramref name="propertyName"/> of the object with
				either same Id or keys as <paramref name="t"/> with value <paramref name="newValue"/>.
			</summary>
			<param name="t">The object to update</param>
			<param name="propertyName">The name of the property to update</param>
			<param name="newValue">
				The new value of the property with name <paramref name="propertyName"/>
			</param>
		</member>
		<member name="M:GenericRepositoryAndService.Service.GenericService`1.UpdateOneCrypted(`0,System.String,System.Object)">
			<summary>
				Update only the property with name <paramref name="propertyName"/> of the object with
				either same Id or keys as <paramref name="t"/> with value <paramref name="newValue"/> after
				having crypted using <see cref="M:GenericRepositoryAndService.Tools.HashTools.ComputeSha256Hash(System.String)"/> if the property
				with name <paramref name="propertyName"/> has the annotation
				<see cref="T:System.ComponentModel.DataAnnotations.DataTypeAttribute"/> with type <see cref="F:System.ComponentModel.DataAnnotations.DataType.Password"/> and have changed
			</summary>
			<param name="t">The object to update</param>
			<param name="propertyName">The name of the property to update</param>
			<param name="newValue">
				The new value of the property with name <paramref name="propertyName"/>
			</param>
		</member>
		<member name="T:GenericRepositoryAndService.Service.IGenericService`1">
			<summary>
				Generic Repository for class <typeparamref name="T"/> using context
				type <see cref="T:System.Data.Entity.DbContext"/>.
				<remark>
					Assumes that :
					<list type="bullet">
						<item>
							every class that either derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
							or has at least one property with annotation <see cref="T:System.ComponentModel.DataAnnotations.KeyAttribute"/>
							has a <see cref="T:System.Data.Entity.DbSet"/> in <see cref="T:System.Data.Entity.DbContext"/>
						</item>
						<item>
							and that reciprocally, every class having a <see cref="T:System.Data.Entity.DbSet"/> in
							<see cref="T:System.Data.Entity.DbContext"/> either derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
							or has at least one property with annotation <see cref="T:System.ComponentModel.DataAnnotations.KeyAttribute"/>.
						</item>
					</list>
					Furthermore, assumes that
					<list type="bullet">
						<item>
							For a class t with name "TName", the corresponding repository is named "TNameRepository"
						</item>
						<item>
							For a class t with name "TName", the corresponding service is named "TNameService"
						</item>
					</list>
				</remark>
			</summary>
			<typeparam name="T"></typeparam>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.Collection(System.Boolean,System.Boolean)">
			<summary>
				Get the IQueryable collection. Specify if all other types in relationship with <typeparamref name="T"/>
				have to be included in the query, and if the elements have to be tracked.
			</summary>
			<param name="isIncludes">
				Whether or not other types in relationship with <typeparamref name="T"/>
				have to be included in the query
			</param>
			<param name="isTracked">Whether or not elements have to be tracked</param>
			<returns>The IQueryable collection</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.CollectionExcludes">
			<summary>
				Get the IQueryable collection, other types in relationship with <typeparamref name="T"/> excluded, elements not tracked.
			</summary>
			<returns>The query</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.CollectionExcludesTracked">
			<summary>
				Get the IQueryable collection, other types in relationship with <typeparamref name="T"/> excluded, elements tracked.
			</summary>
			<returns>The query</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.CollectionIncludes">
			<summary>
				Get the IQueryable collection, other types in relationship with <typeparamref name="T"/> included, elements not tracked.
			</summary>
			<returns>The query</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.CollectionIncludesTracked">
			<summary>
				Get the IQueryable collection, other types in relationship with <typeparamref name="T"/> included, elements tracked.
			</summary>
			<returns>The query</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.Count(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Counts the elements in DB for which the predicate <paramref name="predicateWhere"/> is <see langword="true"/>.
			</summary>
			<remarks>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</remarks>
			<param name="predicateWhere"></param>
			<returns>
				The number of elements in DB satisfying <paramref name="predicateWhere"/>
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.Delete(System.Object[])">
			<summary>
				Deletes the element with either Id or keys <paramref name="objs"/>.
			</summary>
			<param name="objs">Either the Id or keys</param>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.Delete(`0)">
			<summary>
				Deletes the element <paramref name="t"/>
			</summary>
			<param name="t">The element to delete</param>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.FindAll(System.Boolean,System.Boolean,System.Int32,System.Int32,System.String)">
			<summary>
				Get a list of elements ordered by <see cref="M:GenericRepositoryAndService.Service.IGenericService`1.OrderExpression"/> following condition
				<see cref="M:GenericRepositoryAndService.Service.IGenericService`1.SearchExpression(System.String)"/> applied to <paramref name="searchField"/>
				for page <paramref name="page"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be excluded if and only if <paramref name="isIncludes"/> is <see langword="true"/>,
				otherwise every other property will be included.
				<br/>
				Elements will be tracked if and only if <paramref name="isTracked"/> is <see langword="true"/>.
				<br/>
				If <see cref="M:GenericRepositoryAndService.Service.IGenericService`1.OrderExpression"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="isIncludes">Will all other properties be included</param>
			<param name="isTracked">Will the element be tracked</param>
			<param name="page">The page</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="searchField">The string with the search</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.FindAllExcludes(System.Int32,System.Int32,System.String)">
			<summary>
				Get a list of elements ordered by <see cref="M:GenericRepositoryAndService.Service.IGenericService`1.OrderExpression"/> following condition
				<see cref="M:GenericRepositoryAndService.Service.IGenericService`1.SearchExpression(System.String)"/> applied to <paramref name="searchField"/>
				for page <paramref name="page"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be excluded, elements will not be tracked.
				<br/>
				If <see cref="M:GenericRepositoryAndService.Service.IGenericService`1.OrderExpression"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="page">The page</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="searchField">The string with the search</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.FindAllExcludesTracked(System.Int32,System.Int32,System.String)">
			<summary>
				Get a list of elements ordered by <see cref="M:GenericRepositoryAndService.Service.IGenericService`1.OrderExpression"/> following condition
				<see cref="M:GenericRepositoryAndService.Service.IGenericService`1.SearchExpression(System.String)"/> applied to <paramref name="searchField"/>
				for page <paramref name="page"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be excluded, elements will be tracked.
				<br/>
				If <see cref="M:GenericRepositoryAndService.Service.IGenericService`1.OrderExpression"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="page">The page</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="searchField">The string with the search</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.FindAllIncludes(System.Int32,System.Int32,System.String)">
			<summary>
				Get a list of elements ordered by <see cref="M:GenericRepositoryAndService.Service.IGenericService`1.OrderExpression"/> following condition
				<see cref="M:GenericRepositoryAndService.Service.IGenericService`1.SearchExpression(System.String)"/> applied to <paramref name="searchField"/>
				for page <paramref name="page"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be included, elements will not be tracked.
				<br/>
				If <see cref="M:GenericRepositoryAndService.Service.IGenericService`1.OrderExpression"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="page">The page</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="searchField">The string with the search</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.FindAllIncludesTracked(System.Int32,System.Int32,System.String)">
			<summary>
				Get a list of elements ordered by <see cref="M:GenericRepositoryAndService.Service.IGenericService`1.OrderExpression"/> following condition
				<see cref="M:GenericRepositoryAndService.Service.IGenericService`1.SearchExpression(System.String)"/> applied to <paramref name="searchField"/>
				for page <paramref name="page"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be included, elements will be tracked.
				<br/>
				If <see cref="M:GenericRepositoryAndService.Service.IGenericService`1.OrderExpression"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="page">The page</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="searchField">The string with the search</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.FindById(System.Boolean,System.Boolean,System.Object[])">
			<summary>
				Finds an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
				Specify if all other types in relationship with <typeparamref name="T"/>
				have to be included in the query, and if the elements have to be tracked
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="isIncludes">
				Whether or not other types in relationship with <typeparamref name="T"/>
				have to be included in the query
			</param>
			<param name="isTracked">Whether or not elements have to be tracked</param>
			<param name="objs">Either the Id of the object to find, or its keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.FindByIdExcludes(System.Object[])">
			<summary>
				Finds an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> excluded, elements not tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Id of the object to find, or its keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.FindByIdExcludesTracked(System.Object[])">
			<summary>
				Finds an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> excluded, elements tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Id of the object to find, or its keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.FindByIdIncludes(System.Object[])">
			<summary>
				Finds an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> included, elements not tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Id of the object to find, or its keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.FindByIdIncludesTracked(System.Object[])">
			<summary>
				Finds an object from DB having
				<list type="bullet">
					<item>
						either a specific Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or have specific key values otherwise.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> included, elements tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Id of the object to find, or its keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.FindByManyId(System.Boolean,System.Boolean,System.Object[])">
			<summary>
				Finds a list of objects from DB having
				<list type="bullet">
					<item>
						either specific Ids, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or specific key values otherwise, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.EntityWithKeys"/>.
					</item>
				</list>
				Specify if all other types in relationship with <typeparamref name="T"/>
				have to be included in the query, and if the elements have to be tracked
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="isIncludes">
				Whether or not other types in relationship with <typeparamref name="T"/>
				have to be included in the query
			</param>
			<param name="isTracked">Whether or not elements have to be tracked</param>
			<param name="objs">Either the Id of the object to delete, or its keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.FindManyByIdExcludes(System.Object[])">
			<summary>
				Finds a list of objects from DB having
				<list type="bullet">
					<item>
						either specific Ids, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or specific key values otherwise, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.EntityWithKeys"/>.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> excluded, elements not tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Ids of the object to find, or their keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.FindManyByIdExcludesTracked(System.Object[])">
			<summary>
				Finds a list of objects from DB having
				<list type="bullet">
					<item>
						either specific Ids, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or specific key values otherwise, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.EntityWithKeys"/>.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> excluded, elements tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Ids of the object to find, or their keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.FindManyByIdIncludes(System.Object[])">
			<summary>
				Finds a list of objects from DB having
				<list type="bullet">
					<item>
						either specific Ids, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or specific key values otherwise, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.EntityWithKeys"/>.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> included, elements not tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Ids of the object to find, or their keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.FindManyByIdIncludesTracked(System.Object[])">
			<summary>
				Finds a list of objects from DB having
				<list type="bullet">
					<item>
						either specific Ids, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or specific key values otherwise, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.EntityWithKeys"/>.
					</item>
				</list>
				Other types in relationship with <typeparamref name="T"/> included, elements tracked.
			</summary>
			<remarks>
				Keys have to be specified in the same order as they are declared in the class <typeparamref name="T"/>
			</remarks>
			<param name="objs">Either the Ids of the object to find, or their keys values.</param>
			<returns>
				The element, if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.GetAll(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Linq.Expressions.Expression{System.Func{System.Linq.IQueryable{`0},System.Linq.IOrderedQueryable{`0}}},System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements ordered by <paramref name="orderreq"/> following condition <paramref name="predicateWhere"/>
				for page <paramref name="page"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be excluded if and only if <paramref name="isIncludes"/> is <see langword="true"/>,
				otherwise every other property will be included.
				<br/>
				Elements will be tracked if and only if <paramref name="isTracked"/> is <see langword="true"/>.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="isIncludes">Will all other properties be included</param>
			<param name="isTracked">Will the element be tracked</param>
			<param name="page">The page</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="orderreq">Order function</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.GetAllBy(System.Boolean,System.Boolean,System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements following condition <paramref name="predicateWhere"/>.
				<br/>
				Every other property will be excluded if and only if <paramref name="isIncludes"/> is <see langword="true"/>,
				otherwise every other property will be included.
				<br/>
				Elements will be tracked if and only if <paramref name="isTracked"/> is <see langword="true"/>.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="GenericToolsQueriesAndLists.QueryTryPredicateWhere{T}(IQueryable{T}, Expression{Func{T, bool}})"/>
				for more information.

			</summary>
			<param name="isIncludes">Will all other properties be included</param>
			<param name="isTracked">Will the element be tracked</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.GetAllByExcludes(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements following condition <paramref name="predicateWhere"/>.
				<br/>
				Every other property will be excluded, elements will not be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.GetAllByExcludesTracked(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements following condition <paramref name="predicateWhere"/>.
				<br/>
				Every other property will be excluded, elements will be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.GetAllByIncludes(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements following condition <paramref name="predicateWhere"/>.
				<br/>
				Every other property will be included, elements will not be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.GetAllByIncludesTracked(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements following condition <paramref name="predicateWhere"/>.
				<br/>
				Every other property will be included, elements will be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.GetAllExcludes(System.Int32,System.Int32,System.Linq.Expressions.Expression{System.Func{System.Linq.IQueryable{`0},System.Linq.IOrderedQueryable{`0}}},System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements ordered by <paramref name="orderreq"/> following condition <paramref name="predicateWhere"/>
				for page <paramref name="page"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be excluded, elements will not be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="page">The page</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="orderreq">Order function</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.GetAllExcludesTracked(System.Int32,System.Int32,System.Linq.Expressions.Expression{System.Func{System.Linq.IQueryable{`0},System.Linq.IOrderedQueryable{`0}}},System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements ordered by <paramref name="orderreq"/> following condition <paramref name="predicateWhere"/>
				for page <paramref name="page"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be excluded, elements will be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="page">The page</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="orderreq">Order function</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.GetAllIncludes(System.Int32,System.Int32,System.Linq.Expressions.Expression{System.Func{System.Linq.IQueryable{`0},System.Linq.IOrderedQueryable{`0}}},System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements ordered by <paramref name="orderreq"/> following condition <paramref name="predicateWhere"/>
				for page <paramref name="page"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be included, elements will not be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="page">The page</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="orderreq">Order function</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.GetAllIncludesTracked(System.Int32,System.Int32,System.Linq.Expressions.Expression{System.Func{System.Linq.IQueryable{`0},System.Linq.IOrderedQueryable{`0}}},System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
			<summary>
				Get a list of elements ordered by <paramref name="orderreq"/> following condition <paramref name="predicateWhere"/>
				for page <paramref name="page"/> with at most <paramref name="maxByPage"/> elements.
				<br/>
				Every other property will be included, elements will be tracked.
				<br/>
				If <paramref name="predicateWhere"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="page">The page</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="orderreq">Order function</param>
			<param name="predicateWhere">Condition</param>
			<returns>The list of objects</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.List(System.Boolean,System.Boolean)">
			<summary>
				Get the collection as a <see cref="T:System.Collections.Generic.List`1"/>. Specify if all other types in relationship with <typeparamref name="T"/>
				have to be included in the query, and if the elements have to be tracked.
			</summary>
			<param name="isIncludes">
				Whether or not other types in relationship with <typeparamref name="T"/>
				have to be included in the query
			</param>
			<param name="isTracked">Whether or not elements have to be tracked</param>
			<returns>The list</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.ListExcludes">
			<summary>
				Get the collection as a <see cref="T:System.Collections.Generic.List`1"/>, other types in relationship with <typeparamref name="T"/> excluded, elements not tracked.
			</summary>
			<returns>The list</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.ListExcludesTracked">
			<summary>
				Get the collection as a <see cref="T:System.Collections.Generic.List`1"/>, other types in relationship with <typeparamref name="T"/> excluded, elements tracked.
			</summary>
			<returns>The list</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.ListIncludes">
			<summary>
				Get the collection as a <see cref="T:System.Collections.Generic.List`1"/>, other types in relationship with <typeparamref name="T"/> included, elements not tracked.
			</summary>
			<returns>The list</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.ListIncludesTracked">
			<summary>
				Get the collection as a <see cref="T:System.Collections.Generic.List`1"/>, other types in relationship with <typeparamref name="T"/> included, elements tracked.
			</summary>
			<returns>The list</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.NextExist(System.Int32,System.Int32,System.String)">
			<summary>
				Checks whether or not there is another page after <paramref name="page"/>
				for the search using <see cref="M:GenericRepositoryAndService.Service.IGenericService`1.SearchExpression(System.String)"/> having <paramref name="maxByPage"/>
				elements per page.
			</summary>
			<param name="page">The current page number.</param>
			<param name="maxByPage">The maximum number of elements per page.</param>
			<param name="searchField">The string searched.</param>
			<returns>
				Whether or not there is another page after page number <paramref name="page"/>
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.OrderExpression">
			<summary>
				The expression with which the elements will be ordered when using <see cref="M:GenericRepositoryAndService.Service.IGenericService`1.FindAll(System.Boolean,System.Boolean,System.Int32,System.Int32,System.String)"/>.
			</summary>
			<returns>The expression.</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.Save(`0)">
			<summary>
				Saves the element <paramref name="t"/>.
			</summary>
			<param name="t">The element to save</param>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.SaveCrypted(`0)">
			<summary>
				Saves the elements <paramref name="t"/> after having crypted using
				<see cref="M:GenericRepositoryAndService.Tools.HashTools.ComputeSha256Hash(System.String)"/> every string property with annotation
				<see cref="T:System.ComponentModel.DataAnnotations.DataTypeAttribute"/> with type <see cref="F:System.ComponentModel.DataAnnotations.DataType.Password"/>.
			</summary>
			<param name="t">The element to crypt then save.</param>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.SearchExpression(System.String)">
			<summary>
				The expression used to search the elements in <see cref="M:GenericRepositoryAndService.Service.IGenericService`1.FindAll(System.Boolean,System.Boolean,System.Int32,System.Int32,System.String)"/> and
				<see cref="M:GenericRepositoryAndService.Service.IGenericService`1.NextExist(System.Int32,System.Int32,System.String)"/>.
				<br/>
				If <see cref="M:GenericRepositoryAndService.Service.IGenericService`1.OrderExpression"/> fails to be translated from EntityFramework C# LINQ query to
				a SQL command, the predicate will be ignored.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})"/>
				for more information.
			</summary>
			<param name="searchField"></param>
			<returns></returns>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.Update(`0)">
			<summary>
				Updates an element <paramref name="t"/>
			</summary>
			<param name="t">The element to update</param>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.UpdateCrypted(`0)">
			<summary>
				Updates the element <paramref name="t"/> after having crypted using
				<see cref="M:GenericRepositoryAndService.Tools.HashTools.ComputeSha256Hash(System.String)"/> every string property with annotation
				<see cref="T:System.ComponentModel.DataAnnotations.DataTypeAttribute"/> with type <see cref="F:System.ComponentModel.DataAnnotations.DataType.Password"/> that have changed.
			</summary>
			<param name="t">The object to update.</param>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.UpdateOne(`0,System.String,System.Object)">
			<summary>
				Update only the property with name <paramref name="propertyName"/> of the object with
				either same Id or keys as <paramref name="t"/> with value <paramref name="newValue"/>.
			</summary>
			<param name="t">The object to update</param>
			<param name="propertyName">The name of the property to update</param>
			<param name="newValue">
				The new value of the property with name <paramref name="propertyName"/>
			</param>
		</member>
		<member name="M:GenericRepositoryAndService.Service.IGenericService`1.UpdateOneCrypted(`0,System.String,System.Object)">
			<summary>
				Update only the property with name <paramref name="propertyName"/> of the object with
				either same Id or keys as <paramref name="t"/> with value <paramref name="newValue"/> after
				having crypted using <see cref="M:GenericRepositoryAndService.Tools.HashTools.ComputeSha256Hash(System.String)"/> if the property
				with name <paramref name="propertyName"/> has the annotation
				<see cref="T:System.ComponentModel.DataAnnotations.DataTypeAttribute"/> with type <see cref="F:System.ComponentModel.DataAnnotations.DataType.Password"/> and have changed
			</summary>
			<param name="t">The object to update</param>
			<param name="propertyName">The name of the property to update</param>
			<param name="newValue">
				The new value of the property with name <paramref name="propertyName"/>
			</param>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUD.FindByKeysInNewContextForType(System.Type,System.Data.Entity.DbContext,System.Object[])">
			<summary>
				Find an object of type <paramref name="typeofElement"/> with either Id or Keys <paramref name="objs"/>
				in context <paramref name="newContext"/>.
				<br/>
				Essentially, this is a dynamic call to the generic method
				<see cref="M:GenericRepositoryAndService.Repository.GenericRepository`1.FindByIdIncludesTrackedInNewContext(System.Data.Entity.DbContext,System.Object[])"/> where <c>T</c> is <paramref name="typeofElement"/>.
			</summary>
			<remarks>
				Other properties will not be included, and element will be tracked.
			</remarks>
			<param name="typeofElement">The type of the the object searched</param>
			<param name="newContext">The context in which the search has to be done</param>
			<param name="objs">Either the Id or the keys values of the object searched</param>
			<returns>
				The object if found, <see langword="null"/> otherwise.
			</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUD.PrepareDelete``1(System.Data.Entity.DbContext,System.Object[])">
			<summary>
				Every step that has to be taken into account before deleting an object of type <typeparamref name="T"/> having
				either Id or keys <paramref name="objs"/>.
				<br/>
				See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUDPrep.DeleteOtherPropInRelationWithTHavingTPropertyTAndTNotHavingProperty``1(System.Data.Entity.DbContext,System.Type,System.Object[])"/>,
				<see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUDPrep.DeleteOtherPropInRelationWithTHavingRequiredTProperty``1(System.Data.Entity.DbContext,System.Type,System.Object[])"/>,
				<see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUDPrep.DeleteOtherPropInSeveralRelationshipsWithT``1(System.Data.Entity.DbContext,System.Type,System.Object[])"/> for more details.
				<br/>
				In a nutshell :
				<list type="bullet">
					<item>
						Every type <c>q</c> in <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.GetTypesInRelationWithTHavingTPropertyTAndTNotHavingProperty``1"/> has to be updated
						manually.
						<br/>
						Indeed, <typeparamref name="T"/> has no property representing that relation, and thus no element of
						type <c>q</c> will be loaded in the context and changed, wich will result in exceptions if not
						taken care of.
					</item>
					<item>
						Every type <c>q</c> in <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.GetTypesInRelationWithTHavingRequiredTProperty``1"/> has to be updated
						manually.
						<br/>
						Indeed, required properties are not handled well in EF in case of relationships, especially if they are
						of type <see cref="T:System.Collections.IList"/> (an empty <see cref="T:System.Collections.Generic.List`1"/> is not <see langword="null"/> and the annotation
						<see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/> is interpreted as nullable = <see langword="false"/>)
					</item>
					<item>
						Every type <c>q</c> in <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.GetTypesForWhichTHasManyProperties``1"/> has to be updated
						manually.
						<br/>
						Indeed, if we try to remove the object of type <typeparamref name="T"/> using EF, it will load
						in the context all the properties relating to relationship with those types. The point being, there will be many
						properties loaded.
						<br/>
						What can happen is an object of type <c>q</c> might appear multiple times and therefore
						EF will load it multiple times. Thus, an element of type <c>q</c> with the same primary key (or keys) will be loaded in the context,
						which will throw an exception if we simply do db.Set.Delete(item). Therefore, we have to manage those
						separately.
					</item>
				</list>
			</summary>
			<typeparam name="T">The type of the object to delete</typeparam>
			<param name="context">The context</param>
			<param name="objs">Either the Id or the keys of the object to delete</param>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUD.PrepareSave``1(``0)">
			<summary>
				Creates the array of all the values of properties of the element <paramref name="t"/> of type <typeparamref name="T"/>
				to save that represent a relationship involving <typeparamref name="T"/>.
				<br/>
				Furthermore, for types appearing multiple times as properties in <typeparamref name="T"/>, set those to
				<see cref="T:GenericRepositoryAndService.Tools.Generic.PropToNull"/> if necessary. See <see cref="M:GenericRepositoryAndService.Repository.GenericRepository`1.Save(`0,System.Object[])"/> for further details.
			</summary>
			<typeparam name="T">The type of the element to save</typeparam>
			<param name="t">The element to save</param>
			<returns>
				The array of all the values of properties of <paramref name="t"/> representing relationships involving <typeparamref name="T"/>,
				with values set to <see cref="T:GenericRepositoryAndService.Tools.Generic.PropToNull"/> if necessary.
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUD.PrepareUpdate``1(System.Data.Entity.DbContext,``0)">
			<summary>
				Prepares update for object <paramref name="t"/> of type <typeparamref name="T"/>. Every type <c>q</c> in
				<see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.GetTypesInRelationWithTHavingRequiredTProperty``1"/> has to be updated
				manually. Indeed, required properties are not handled well in EF in case of relationships, especially if they are
				of type <see cref="T:System.Collections.IList"/> (an empty <see cref="T:System.Collections.IList"/> is not <see langword="null"/> and the annotation
				<see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/> is interpreted as nullable = <see langword="false"/>).
				<br/>
				Creates the array of all the values of properties of the element <paramref name="t"/> of type <typeparamref name="T"/>
				to update that represent a relationship involving <typeparamref name="T"/>.
				<br/>
				Furthermore, for types appearing multiple times as properties in <typeparamref name="T"/>, set those to
				<see cref="T:GenericRepositoryAndService.Tools.Generic.PropToNull"/> if necessary. See <see cref="M:GenericRepositoryAndService.Repository.GenericRepository`1.Save(`0,System.Object[])"/> for further details.
			</summary>
			<typeparam name="T">The type of the element to update</typeparam>
			<param name="context">The context</param>
			<param name="t">The element to update</param>
			<returns>
				The array of all the values of properties of <paramref name="t"/> representing relationships involving <typeparamref name="T"/>,
				with values set to <see cref="T:GenericRepositoryAndService.Tools.Generic.PropToNull"/> if necessary.
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUD.PrepareUpdateOne``1(System.Data.Entity.DbContext,``0,System.String)">
			<summary>
				Prepares update for object <paramref name="t"/> of type <typeparamref name="T"/>. Every type <c>q</c> in
				<see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.GetTypesInRelationWithTHavingRequiredTProperty``1"/> has to be updated
				manually. Indeed, required properties are not handled well in EF in case of relationships, especially if they are
				of type <see cref="T:System.Collections.IList"/> (an empty <see cref="T:System.Collections.IList"/> is not <see langword="null"/> and the annotation
				<see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/> is interpreted as nullable = <see langword="false"/>).
			</summary>
			<remarks>
				Only the property of <paramref name="t"/> with name <paramref name="propertyName"/> will be updated.
			</remarks>
			<typeparam name="T">The type of the element to update</typeparam>
			<param name="context">The context</param>
			<param name="t">The element to update</param>
			<param name="propertyName">The name of the property</param>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUDCrypt.Crypt``1(``0)">
			<summary>
				Crypt every password of <paramref name="t"/> of type <typeparamref name="T"/> using <see cref="M:GenericRepositoryAndService.Tools.HashTools.ComputeSha256Hash(System.String)"/>.
			</summary>
			<typeparam name="T">The type of the object</typeparam>
			<param name="t">The object</param>
			<returns>The object crypted</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUDCrypt.CryptIfUpdated``1(``0,``0)">
			<summary>
				Crypt every password that have changed from <paramref name="told"/> to <paramref name="tnew"/> of type <typeparamref name="T"/> using
				<see cref="M:GenericRepositoryAndService.Tools.HashTools.ComputeSha256Hash(System.String)"/>.
			</summary>
			<typeparam name="T">The type of the object</typeparam>
			<param name="told">The old value of the item, still in DB</param>
			<param name="tnew">The new value of the item, with passwords to crypt if changed</param>
			<returns>The item crypted</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUDCrypt.CryptIfUpdatedOne``1(``0,``0,System.String,System.Object)">
			<summary>
				Crypt the property <paramref name="propertyName"/> of the object <paramref name="tnew"/> of type <typeparamref name="T"/>
				if its value changed using <see cref="M:GenericRepositoryAndService.Tools.HashTools.ComputeSha256Hash(System.String)"/>.
			</summary>
			<typeparam name="T">The type of the object</typeparam>
			<param name="told">The old value of the item, still in DB</param>
			<param name="tnew">The new value of the item</param>
			<param name="propertyName">The name of the property to change</param>
			<param name="newValue">The new value</param>
			<returns>The object crypted</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUDPrep.GetServiceFromContext(System.Data.Entity.DbContext,System.Type)">
			<summary>
				Get an instance of the service of type <paramref name="t"/> using <paramref name="context"/>.
			</summary>
			<remarks>
				There are some restrictions on the names of the classes, the repositories and the services :
				<list type="bullet">
					<item>
						For a class t with name "TName", the corresponding repository must be named "TNameRepository"
					</item>
					<item>
						For a class t with name "TName", the corresponding service must be named "TNameService"
					</item>
				</list>
			</remarks>
			<param name="context">The context</param>
			<param name="t">The type for which the service has to be instanciated</param>
			<returns>
				A new instance of the service of <paramref name="t"/>
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUDPrep.SetForTypePropertyWithGivenKeysToNullInNewContext``1(System.Data.Entity.DbContext,System.Type,System.String,System.Object[])">
			<summary>
				For the type <paramref name="q"/>, using a new context <paramref name="context"/>, update the elements in case
				the element of type <typeparamref name="T"/> having either Id or keys <paramref name="objs"/> has to be deleted. That is
				to say, for elements of type <paramref name="q"/> such that their property <paramref name="propname"/> of type <typeparamref name="T"/>
				is not <see langword="null"/>,
				<list type="bullet">
					<item>
						If the property doesn't have an annotation <see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/>, just set it to <see langword="null"/>.
						(EF won't do it by itself using TRepository since <typeparamref name="T"/> has no property for that relationship)
					</item>
					<item>
						If the property has an annotation <see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/>, delete the item (EF won't do it by itself for
						the same reason)
					</item>
				</list>
			</summary>
			<remarks>
				It is assumed that the property of <paramref name="q"/> with name <paramref name="propname"/> is of
				type <typeparamref name="T"/> (and NOT <see cref="T:System.Collections.Generic.IList`1"/>) and that <typeparamref name="T"/> has no
				property representing that relationship. In other words it is assumed that <paramref name="q"/> is part
				of <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.GetTypesInRelationWithTHavingTPropertyTAndTNotHavingProperty``1"/>
			</remarks>
			<typeparam name="T">
				The type of the element deleted with either Id or keys <paramref name="objs"/> for which actions
				have to be taken
			</typeparam>
			<param name="context">The context in which to do this operation</param>
			<param name="q">
				The type of the elements to be updated before the deletion of the element of type <typeparamref name="T"/> with
				either Id or keys <paramref name="objs"/>
			</param>
			<param name="propname">
				The name of the property of <paramref name="q"/> having type <typeparamref name="T"/>
			</param>
			<param name="objs">
				Either the Id or keys of the element of type <typeparamref name="T"/> deleted
			</param>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUDPrep.ConcatArrayWithParams(System.Object[],System.Object[])">
			<summary>
				Get a new array with elements :
				<list type="bullet">
					<item>
						the elements of <paramref name="objs"/>
					</item>
					<item>
						the array <paramref name="paramsobjects"/>
					</item>
				</list>
			</summary>
			<remarks>
				Used to a dynamic call to a generic function having arguments
				(obj arg1, ... obj argn, params object[] paramsobject).
				<br/>
				<paramref name="objs"/> will contain {arg1, ... , argn}
				<br/>
				The dynamic call will use <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUDPrep.ConcatArrayWithParams(System.Object[],System.Object[])"/> with arguments (<paramref name="objs"/>,<paramref name="paramsobjects"/>)
			</remarks>
			<param name="objs">The objects</param>
			<param name="paramsobjects">The array of objects used in params argument.</param>
			<returns>The array.</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUDPrep.RemoveForTypePropertyListElementWithGivenKeyInNewContext``1(System.Data.Entity.DbContext,System.Type,System.String,System.Object[])">
			<summary>
				In a given context <paramref name="context"/>, for the type <paramref name="q"/> with the property with name
				<paramref name="propname"/> of type <typeparamref name="T"/>, prepare the deletion of a given element of type <typeparamref name="T"/>
				with either Id or keys <paramref name="objs"/>.
				<br/>
				That is to say, for every element of type <paramref name="q"/> such that
				their property <paramref name="propname"/> is of type <see cref="T:System.Collections.Generic.IList`1"/> and contains the element of either Id or keys
				<paramref name="objs"/>
				<list type="bullet">
					<item>
						if the property <paramref name="propname"/> of <paramref name="q"/> has the annotation <see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/> and the
						list has only the item to delete remaining, remove the element of type <paramref name="q"/>
					</item>
					<item>
						otherwise just remove the element from the list.
					</item>
				</list>
			</summary>
			<typeparam name="T">The type of the element to be deleted</typeparam>
			<param name="context">The context</param>
			<param name="q">The type of the elements to be updated</param>
			<param name="propname">
				The name of the property of q of type <see cref="T:System.Collections.Generic.IList`1"/>
			</param>
			<param name="objs">Either the Id or the keys</param>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUDPrep.DeleteOtherPropInRelationWithTHavingTPropertyTAndTNotHavingProperty``1(System.Data.Entity.DbContext,System.Type,System.Object[])">
			<summary>
				An object of type <typeparamref name="T"/> with either Id or keys <paramref name="objs"/> is deleted.
				Every type <paramref name="q"/> in <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.GetTypesInRelationWithTHavingTPropertyTAndTNotHavingProperty``1"/> has to be updated
				manually. Indeed, <typeparamref name="T"/> has no property representing that relation, and thus no element of
				type <paramref name="q"/> will be loaded in the context and changed, wich will result in exceptions if not
				taken care of. This is such treatment.
				<br/>
				If the property representing that relation in type <paramref name="q"/> is of type <typeparamref name="T"/>,
				this will set, for the appropriate elements of type <paramref name="q"/>, either the property to <see langword="null"/>,
				or if it has annotation <see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/> it will delete it.
				<br/>
				if the property representing that relation in type <paramref name="q"/> is of type <see cref="T:System.Collections.Generic.IList`1"/>,
				this will set, for the appropriate elements of type <paramref name="q"/>, the property to the list without the element
				with either Id or keys <paramref name="objs"/>. Furthermore, if such property has annotation <see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/>,
				and the item of type <typeparamref name="T"/> to delete was the only remaining element of the list, it will delete
				the element of type <paramref name="q"/> in question.
			</summary>
			<typeparam name="T">The type of the element we wish to delete</typeparam>
			<param name="context">The context</param>
			<param name="q">The type to update</param>
			<param name="objs">Either the Id or the Keys of the item we wish to delete</param>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUDPrep.DeleteItemOfTypeWithRequiredPropertyHavingGivenKeysInNewContext``1(System.Data.Entity.DbContext,System.Type,System.String,System.Object[])">
			<summary>
				For the type <paramref name="q"/>, using a new context <paramref name="context"/>, update the elements in case
				the element of type <typeparamref name="T"/> having either Id or keys <paramref name="objs"/> has to be deleted
				and the property of <paramref name="q"/> of type either <typeparamref name="T"/> or <see cref="T:System.Collections.Generic.IList`1"/> has
				the annotation <see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/>.
				<br/>
				Indeed, required properties are not handled well in EF in case of relationships, especially if they are
				of type <see cref="T:System.Collections.Generic.IList`1"/> (an empty <see cref="T:System.Collections.IList"/> is not <see langword="null"/> and the annotation
				<see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/> is interpreted as nullable = <see langword="false"/> and empty list are
				thusly accepted)
				<br/> That is to say, for elements of type <paramref name="q"/>, if the property has an annotation
				<see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/>, and :
				<list type="bullet">
					<item>
						it is of type <typeparamref name="T"/>, delete the item
					</item>
					<item>
						it is of type <see cref="T:System.Collections.Generic.IList`1"/>, remove the item from the list and delete the element if it were
						the only element remaining in the property.
					</item>
				</list>
			</summary>
			<remarks>
				It is assumed that the property of <paramref name="q"/> with name <paramref name="propname"/> is of
				type <typeparamref name="T"/> (and NOT <see cref="T:System.Collections.Generic.IList`1"/>,
				see <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUDPrep.DeleteOrUpdateItemOfTypeWithRequiredListPropertyHavingGivenKeysInNewContext``1(System.Data.Entity.DbContext,System.Type,System.String,System.Object[])"/> for that case)
				and that <typeparamref name="T"/> has no property representing that relationship. In other words it is assumed
				that <paramref name="q"/> is part of <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.GetTypesInRelationWithTHavingRequiredTProperty``1"/> with a property
				of type <typeparamref name="T"/>.
			</remarks>
			<typeparam name="T">
				The type of the element deleted with either Id or keys <paramref name="objs"/> for which actions
				have to be taken
			</typeparam>
			<param name="context">The context in which to do this operation</param>
			<param name="q">
				The type of the elements to be updated before the deletion of the element of type <typeparamref name="T"/> with
				either Id or keys <paramref name="objs"/>
			</param>
			<param name="propname">
				The name of the property of <paramref name="q"/> having type <typeparamref name="T"/>
			</param>
			<param name="objs">
				Either the Id or keys of the element of type <typeparamref name="T"/> deleted
			</param>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUDPrep.DeleteOrUpdateItemOfTypeWithRequiredListPropertyHavingGivenKeysInNewContext``1(System.Data.Entity.DbContext,System.Type,System.String,System.Object[])">
			<summary>
				For the type <paramref name="q"/>, using a new context <paramref name="context"/>, update the elements in case
				the element of type <typeparamref name="T"/> having either Id or keys <paramref name="objs"/> has to be deleted
				and the property of <paramref name="q"/> of type either <typeparamref name="T"/> or <see cref="T:System.Collections.Generic.IList`1"/> has
				the annotation <see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/>.
				<br/>
				Indeed, required properties are not handled well in EF in case of relationships, especially if they are
				of type <see cref="T:System.Collections.Generic.IList`1"/> (an empty <see cref="T:System.Collections.IList"/> is not <see langword="null"/> and the annotation
				<see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/> is interpreted as nullable = <see langword="false"/> and empty list are
				thusly accepted)
				<br/> That is to say, for elements of type <paramref name="q"/>, if the property has an annotation
				<see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/>, and :
				<list type="bullet">
					<item>
						it is of type <typeparamref name="T"/>, delete the item
					</item>
					<item>
						it is of type <see cref="T:System.Collections.Generic.IList`1"/>, remove the item from the list and delete the element if it were
						the only element remaining in the property.
					</item>
				</list>
			</summary>
			<remarks>
				It is assumed that the property of <paramref name="q"/> with name <paramref name="propname"/> is of
				type <see cref="T:System.Collections.Generic.IList`1"/> (and NOT <typeparamref name="T"/>,
				see <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUDPrep.DeleteItemOfTypeWithRequiredPropertyHavingGivenKeysInNewContext``1(System.Data.Entity.DbContext,System.Type,System.String,System.Object[])"/> for that case)
				and that <typeparamref name="T"/> has no property representing that relationship. In other words it is assumed
				that <paramref name="q"/> is part of <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.GetTypesInRelationWithTHavingRequiredTProperty``1"/> with a property
				of type <typeparamref name="T"/>.
			</remarks>
			<typeparam name="T">
				The type of the element deleted with either Id or keys <paramref name="objs"/> for which actions
				have to be taken
			</typeparam>
			<param name="context">The context in which to do this operation</param>
			<param name="q">
				The type of the elements to be updated before the deletion of the element of type <typeparamref name="T"/> with
				either Id or keys <paramref name="objs"/>
			</param>
			<param name="propname">
				The name of the property of <paramref name="q"/> having type <typeparamref name="T"/>
			</param>
			<param name="objs">
				Either the Id or keys of the element of type <typeparamref name="T"/> deleted
			</param>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUDPrep.DeleteOtherPropInRelationWithTHavingRequiredTProperty``1(System.Data.Entity.DbContext,System.Type,System.Object[])">
			<summary>
				An object of type <typeparamref name="T"/> with either Id or keys <paramref name="objs"/> is deleted.
				Every type <paramref name="q"/> in <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.GetTypesInRelationWithTHavingRequiredTProperty``1"/> has to be updated
				manually. Indeed, required properties are not handled well in EF in case of relationships, especially if they are
				of type <see cref="T:System.Collections.IList"/> (an empty <see cref="T:System.Collections.Generic.List`1"/> is not <see langword="null"/> and the annotation
				<see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/> is interpreted as nullable = <see langword="false"/>)
				<br/>
				If the property representing that relation in type <paramref name="q"/> is of type <typeparamref name="T"/>,
				this will set, for the appropriate elements of type <paramref name="q"/>, either the property to <see langword="null"/>,
				or if it has annotation <see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/> it will delete it.
				<br/>
				if the property representing that relation in type <paramref name="q"/> is of type <see cref="T:System.Collections.Generic.IList`1"/>,
				this will set, for the appropriate elements of type <paramref name="q"/>, the property to the list without the element
				with either Id or keys <paramref name="objs"/>. Furthermore, if such property has annotation <see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/>,
				and the item of type <typeparamref name="T"/> to delete was the only remaining element of the list, it will delete
				the element of type <paramref name="q"/> in question.
			</summary>
			<typeparam name="T">The type of the object we wish to delete</typeparam>
			<param name="context">The context</param>
			<param name="q">The type being handled</param>
			<param name="objs">
				The Id or Keys of the object of type <typeparamref name="T"/> to delete
			</param>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUDPrep.SetForMultipleTypePropertyWithGivenKeysToNullInNewContext``1(System.Data.Entity.DbContext,System.Type,System.Collections.Generic.List{System.String},System.Object[])">
			<summary>
				For the type <paramref name="q"/>, using a new context <paramref name="context"/>, update the elements in case
				the element of type <typeparamref name="T"/> having either Id or keys <paramref name="objs"/> has to be deleted. That is
				to say, for elements of type <paramref name="q"/> such that their properties <paramref name="propnames"/> of type <typeparamref name="T"/>
				is not <see langword="null"/>,
				<list type="bullet">
					<item>
						If the property doesn't have an annotation <see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/>, just set it to <see langword="null"/>.
						(EF won't do it by itself using TRepository since <typeparamref name="T"/> has no property for that relationship)
					</item>
					<item>
						If the property has an annotation <see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/>, delete the item (EF won't do it by itself for
						the same reason)
					</item>
				</list>
			</summary>
			<remarks>
				It is assumed that the properties of <paramref name="q"/> with name <paramref name="propnames"/> is of
				type <typeparamref name="T"/> (and NOT <see cref="T:System.Collections.Generic.IList`1"/>) and that <typeparamref name="T"/> has no
				property representing that relationship. In other words it is assumed that <paramref name="q"/> is part
				of <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.GetTypesForWhichTHasManyProperties``1"/>
			</remarks>
			<typeparam name="T">
				The type of the element deleted with either Id or keys <paramref name="objs"/> for which actions
				have to be taken
			</typeparam>
			<param name="context">The context in which to do this operation</param>
			<param name="q">
				The type of the elements to be updated before the deletion of the element of type <typeparamref name="T"/> with
				either Id or keys <paramref name="objs"/>
			</param>
			<param name="propnames">
				The names of the properties of <paramref name="q"/> having type <typeparamref name="T"/>
			</param>
			<param name="objs">
				Either the Id or keys of the element of type <typeparamref name="T"/> deleted
			</param>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUDPrep.RemoveForMultipleTypePropertyListElementWithGivenKeyInNewContext``1(System.Data.Entity.DbContext,System.Type,System.Collections.Generic.List{System.String},System.Object[])">
			<summary>
				In a given context <paramref name="context"/>, for the type <paramref name="q"/> with the properties with name
				<paramref name="propnames"/> of type <typeparamref name="T"/>, prepare the deletion of a given element of type <typeparamref name="T"/>
				with either Id or keys <paramref name="objs"/>.
				<br/>
				That is to say, for every element of type <paramref name="q"/> such that
				their properties <paramref name="propnames"/> is of type <see cref="T:System.Collections.Generic.IList`1"/> and contains the element of either Id or keys
				<paramref name="objs"/>
				<list type="bullet">
					<item>
						if one of the property <paramref name="propnames"/> of <paramref name="q"/> has the annotation <see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/> and the
						list has only the item to delete remaining, remove the element of type <paramref name="q"/>
					</item>
					<item>
						otherwise just remove the element from the list.
					</item>
				</list>
			</summary>
			<typeparam name="T">The type of the element to be deleted</typeparam>
			<param name="context">The context</param>
			<param name="q">The type of the elements to be updated</param>
			<param name="propnames">
				The names of the properties of q of type <see cref="T:System.Collections.Generic.IList`1"/>
			</param>
			<param name="objs">Either the Id or the keys</param>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUDPrep.DeleteOtherPropInSeveralRelationshipsWithT``1(System.Data.Entity.DbContext,System.Type,System.Object[])">
			<summary>
				An object of type <typeparamref name="T"/> with either Id or keys <paramref name="objs"/> is deleted.
				Every type <paramref name="q"/> in <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.GetTypesForWhichTHasManyProperties``1"/> has to be updated
				manually. Indeed, if we try to remove the object of type <typeparamref name="T"/> using EF, it will load
				in the context all the properties relating to relationship with those types. The point being, there will be many
				properties loaded. What can happen is an object of type <paramref name="q"/> might appear multiple times and therefore
				EF will load it multiple times. Thus, an element of type <paramref name="q"/> with the same primary key (or keys) will be loaded in the context,
				which will throw an exception if we simply do db.Set.Delete(item). Therefore, we have to manage those
				separately.
				<br/>
				For now this does not work.
			</summary>
			<typeparam name="T">The type of the object we wish to delete</typeparam>
			<param name="context">The context</param>
			<param name="q">The type being handled</param>
			<param name="objs">
				The Id or Keys of the object of type <typeparamref name="T"/> to delete
			</param>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUDPrep.UpdateItemOfTypeWithRequiredPropOfTypeInNewContext``1(System.Data.Entity.DbContext,System.Type,System.String,``0,System.Object[])">
			<summary>
				An object of type <typeparamref name="T"/> with either Id or keys <paramref name="objs"/> is about to be updated to value <paramref name="newItem"/>.
				The type <paramref name="q"/> has a required property of type <typeparamref name="T"/>,
				and therefore if the relationship between those types changes, some items of type <paramref name="q"/> may be removed.
				<br/>
				In more details, elements of type <paramref name="q"/> to be removed are such that :
				<list type="bullet">
					<item>
						q.qpropname = olditem (before update)
					</item>
					<item>
						newItem.tpropname changes value
					</item>
				</list>
			</summary>
			<typeparam name="T">The type of object to be updated</typeparam>
			<param name="context">The context</param>
			<param name="q">the type of objects to remove if necessary</param>
			<param name="tpropname">The name of the property for t</param>
			<param name="newItem">The new value to be updated</param>
			<param name="objs">
				Either the id or keys of <paramref name="newItem"/>
			</param>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUDPrep.UpdateItemOfTypeWithRequiredPropOfListTypeInNewContext``1(System.Data.Entity.DbContext,System.Type,System.String,System.String,``0,System.Object[])">
			<summary>
				An object of type <typeparamref name="T"/> with either Id or keys <paramref name="objs"/> is about to be updated to value <paramref name="newItem"/>.
				The type <paramref name="q"/> has a required property of name <paramref name="qpropname"/> and of type <see cref="T:System.Collections.Generic.IList`1"/>,
				and therefore if the relationship between those types changes, some items of type <paramref name="q"/> may be removed.
				<br/>
				In more details, elements of type <paramref name="q"/> to be removed are such that :
				<list type="bullet">
					<item>
						q.qpropname contains only oldvalue (before update)
					</item>
					<item>
						newItem.<paramref name="tpropname"/> changes value
					</item>
				</list>
			</summary>
			<typeparam name="T">The type of object to be updated</typeparam>
			<param name="context">The context</param>
			<param name="q">the type of objects to remove if necessary</param>
			<param name="qpropname">The name of the property for q</param>
			<param name="tpropname">The name of the property for t</param>
			<param name="newItem">The new value to be updated</param>
			<param name="objs">
				Either the id or keys of <paramref name="newItem"/>
			</param>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsCRUDPrep.UpdateOtherPropInRelationWithTHavingRequiredTProperty``1(System.Data.Entity.DbContext,System.Type,``0,System.String,System.String)">
			<summary>
				When an element of type <typeparamref name="T"/> get updated, some action have to be taken for types with
				a relationship with <typeparamref name="T"/> and a property of type either <typeparamref name="T"/> or <see cref="T:System.Collections.Generic.IList`1"/> that is
				required.
				<br/>
				Indeed, required properties are not handled well in EF in case of relationships, especially if they are
				of type <see cref="T:System.Collections.IList"/> (an empty <see cref="T:System.Collections.Generic.List`1"/> is not <see langword="null"/> and the annotation
				<see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/> is interpreted as nullable = <see langword="false"/>)
				<br/>
				This handles it and removes the items of type <paramref name="q"/> that either :
				<list type="bullet">
					<item>
						have a property of type <typeparamref name="T"/> that is required, and that <paramref name="newItem"/> is no longer
						linked to that element
					</item>
					<item>
						have a property of type <see cref="T:System.Collections.Generic.IList`1"/> that is required, and that <paramref name="newItem"/> was the last
						element of the list but is no longer linked to that element
					</item>
				</list>
			</summary>
			<typeparam name="T">The type of the item being updated</typeparam>
			<param name="context">The context</param>
			<param name="q">The type of the elements being removed if necessary</param>
			<param name="newItem">The new item to be updated</param>
			<param name="tpropname">
				The name of the property of type <typeparamref name="T"/>
			</param>
			<param name="qpropname">
				The name of the property of type <paramref name="q"/>
			</param>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsExpressionTrees.PropertyEquals``1(System.Reflection.PropertyInfo,System.Object)">
			<summary>
				Construct the expression tree for a lambda expression (<c>o => o.prop == value</c>) dynamically
				<br/>
				Purpose : LINQ to SQL interpretation will be successfull.
				Something using reflection such as
				<br/>
				<c>o => o.GetType().GetProperty("prop").GetValue(o)==value</c>
				<br/>
				doesn't work : LINQ to ENTITY won't work.
				<br/>
				The object is of type <typeparamref name="TItem"/>, value,
				the property to check is <paramref name="property"/> and the value is <paramref name="value"/>.
			</summary>
			<remarks>
				Thanks internet for this one (had to modify it a little bit though)
			</remarks>
			<typeparam name="TItem">
				The type of the object the lambda expression will test whether or not the
				property <paramref name="property"/> is equal to <paramref name="value"/>
			</typeparam>
			<param name="property">The property</param>
			<param name="value">The value</param>
			<returns>
				The lambda expression properly constructed so that LINQ to SQL interpretation will be
				successfull
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsExpressionTrees.GetKey``2(System.Reflection.PropertyInfo)">
			<summary>
				Construct the expression tree for a lambda expression (<c>o => o.prop</c>) dynamically
				<br/>
				Purpose : LINQ to SQL interpretation will be successfull.
				Something using reflection such as
				<br/>
				<c>o => o.GetType().GetProperty("prop").GetValue(o)</c>
				<br/>
				doesn't work : LINQ to ENTITY won't work.
				<br/>
				The object is of type <typeparamref name="TItem"/>,
				the property to specify is <paramref name="property"/> and is of type <typeparamref name="TKey"/>.
			</summary>
			<typeparam name="TItem">
				The type of the object the lambda expression will specify the property
				<paramref name="property"/>.
			</typeparam>
			<typeparam name="TKey">
				The type of the property <paramref name="property"/>
			</typeparam>
			<param name="property">The property to specify</param>
			<returns>
				The lambda expression properly constructed so that LINQ to SQL interpretation will be
				successfull
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsExpressionTrees.ExpressionPropPropEquals``1(System.Reflection.PropertyInfo,System.Reflection.PropertyInfo,System.Object)">
			<summary>
				Build the expression tree for <c>o => (o.prop1.prop2 == value)</c> where o is of type <typeparamref name="TItem"/>.
			</summary>
			<typeparam name="TItem">The type of item at the root of the expression tree</typeparam>
			<param name="prop1">The first property to access</param>
			<param name="prop2">The second property to access</param>
			<param name="value">The value</param>
			<returns>The expression tree</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsExpressionTrees.PropertyKeysNotNull``1(System.Reflection.PropertyInfo)">
			<summary>
				Build the expression tree for <c>o => o.prop != null</c> where o is of type <typeparamref name="TItem"/>.
			</summary>
			<typeparam name="TItem">The type of item at the root of the expression tree</typeparam>
			<param name="prop">The property to access</param>
			<returns>The expression tree</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsExpressionTrees.ExpressionWhereKeysAre``1(System.Object[])">
			<summary>
				Get an expression tree with principal root of type <typeparamref name="T"/>, checking whether or not
				the element has either Id or keys equal to <paramref name="objs"/>.
				<br/>
				Essentially, does either <c>t => t.Id == id</c> or <c>t => t.key1 == key1value &amp;&amp; ... &amp;&amp; t.keyn = keynvalue</c>
			</summary>
			<typeparam name="T">The type in question</typeparam>
			<param name="objs">Either the Id or the keys</param>
			<returns>The expression tree</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsExpressionTrees.ExpressionListWherePropListCountainsElementWithGivenKeys``2(System.Reflection.PropertyInfo,System.Object[])">
			<summary>
				Get an expression tree having root of type <typeparamref name="Q"/>. These elements have a property <paramref name="prop"/>
				which is a list of elements of type <typeparamref name="T"/>.
				<br/>
				This returns essentially : <c>q => q.prop.Where(t => t.keysorId == objs).Count() >= 1</c>
				<br/>
				That is to say, for an element of type <typeparamref name="Q"/> so that their property <paramref name="prop"/> is
				a <see cref="T:System.Collections.Generic.IList`1"/>, whether or not it contains an element with either Id or Key given by <paramref name="objs"/>.
			</summary>
			<typeparam name="T">The most nested type</typeparam>
			<typeparam name="Q">The type of the expression tree root</typeparam>
			<param name="prop">
				The property of <typeparamref name="Q"/> in question
			</param>
			<param name="objs">Either the Id or the Key</param>
			<returns>The expression tree.</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsExpressionTrees.ExpressionListWherePropListCountainsOnlyElementWithGivenKeys``2(System.Reflection.PropertyInfo,System.Object[])">
			<summary>
				Get an expression tree having root of type <typeparamref name="Q"/>. These elements have a property <paramref name="prop"/>
				which is a list of elements of type <typeparamref name="T"/>.
				<br/>
				This returns essentially : <c>q => q.prop.Where(t => t.keysorId == objs).Count() == 1 &amp;&amp; q.prop.Count() == 1</c>
				<br/>
				That is to say, for an element of type <typeparamref name="Q"/> so that their property <paramref name="prop"/> is
				a <see cref="T:System.Collections.Generic.IList`1"/>, whether or not it contains only an element with either Id or Key given by <paramref name="objs"/>.
			</summary>
			<typeparam name="T">The most nested type</typeparam>
			<typeparam name="Q">The type of the expression tree root</typeparam>
			<param name="prop">
				The property of <typeparamref name="Q"/> in question
			</param>
			<param name="objs">Either the Id or the Key</param>
			<returns>The expression tree.</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsExpressionTrees.ExpressionListRemoveElementWithGivenKeys``1(System.Object[])">
			<summary>
				Create an expression tree with principal root of type <typeparamref name="T"/> so that
				one of the keys is different than the given <paramref name="objs"/>
				<br/>
				Essentially gives <c>t => t.key1 != key1value || ... || t.keyn != keynvalue</c>
			</summary>
			<remarks>
				It is assumed that <paramref name="objs"/> are keys and not an Id. See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsExpressionTrees.ExpressionListRemoveElementWithGivenId``1(System.Nullable{System.Int32})"/>
				to see the other case.
			</remarks>
			<typeparam name="T">The type invistigated</typeparam>
			<param name="objs">The Keys</param>
			<returns>The expression tree</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsExpressionTrees.ExpressionListRemoveElementWithGivenId``1(System.Nullable{System.Int32})">
			<summary>
				Create an expression tree with principal root of type <typeparamref name="T"/> so that the
				Id is different from the given <paramref name="id"/>
				<br/>
				Essentially gives <c>t => t.Id != id</c>
			</summary>
			<remarks>
				It is assumed that the Id is given, not keys. See <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsExpressionTrees.ExpressionListRemoveElementWithGivenKeys``1(System.Object[])"/>
				to see the other case.
			</remarks>
			<typeparam name="T">The type invistigated</typeparam>
			<param name="id">The id</param>
			<returns>The expression tree</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsExpressionTrees.ExpressionListWhereMultiplePropListCountainsElementWithGivenKeys``2(System.Collections.Generic.List{System.String},System.Object[])">
			<summary>
				Get an expression tree having root of type <typeparamref name="Q"/>. These elements have properties <paramref name="propnames"/>
				which is a list of elements of type <typeparamref name="T"/>.
				<br/>
				This returns essentially : <c>q => q.prop1.Where(t => t.keysorId == objs).Count() >= 1 &amp;&amp; ... &amp;&amp; q.propn.Where(t => t.keysorId == objs).Count() >= 1</c>
				<br/>
				That is to say, for an element of type <typeparamref name="Q"/> so that their properties <paramref name="propnames"/> is
				a <see cref="T:System.Collections.Generic.IList`1"/>, whether or not all of them contains an element with either Id or Key given by <paramref name="objs"/>.
			</summary>
			<typeparam name="T">The most nested type</typeparam>
			<typeparam name="Q">The type of the expression tree root</typeparam>
			<param name="propnames">
				The properties names of <typeparamref name="Q"/> in question
			</param>
			<param name="objs">Either the Id or the Key</param>
			<returns>The expression tree.</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsExpressionTrees.ExpressionListWhereOtherTypePropListNotContains``2(``0,System.String,System.Int32)">
			<summary>
				Get an expression tree having principal root of type <typeparamref name="Q"/>, for testing whether or not an element
				<paramref name="newItem"/> of type <typeparamref name="T"/> with property <paramref name="tPropName"/> of type <see cref="T:System.Collections.Generic.IList`1"/>
				does not contain the element tested.
				<br/>
				Essentially, does <c>q => !newitem.tpropname.Where(qq => qq.Id == q.Id).Count() == 1)</c>
			</summary>
			<typeparam name="T">
				The type of the <paramref name="newItem"/>
			</typeparam>
			<typeparam name="Q">The type of the elements invistigated</typeparam>
			<param name="newItem">The object</param>
			<param name="tPropName">
				The name of the property of <typeparamref name="T"/> in question
			</param>
			<param name="nbr">
				The number of keys for objects of type <typeparamref name="Q"/> if appropriate
			</param>
			<returns>The expression tree</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTInclude``1(System.Data.Entity.DbContext)">
			<summary>
				Setup all possible and necessary Include(propertyname) for <see cref="T:System.Data.Entity.DbSet"/> queries.
			</summary>
			<param name="dbContext">The context used for the query</param>
			<typeparam name="T">The type invistigated.</typeparam>
			<returns>The query. Essentially, context.DbSetName.AsNoTracking().Include(...).Include(...)....Include(...)</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTIncludeTracked``1(System.Data.Entity.DbContext)">
			<summary>
				Setup all possible and necessary Include(propertyname) for <see cref="T:System.Data.Entity.DbSet"/> queries.
			</summary>
			<param name="dbContext">The context used for the query</param>
			<typeparam name="T">The type invistigated.</typeparam>
			<returns>The query. Essentially, context.DbSetName.Include(...).Include(...)....Include(...)</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryWhereKeysAre``1(System.Linq.IQueryable{``0},System.Object[])">
			<summary>
				From a query <paramref name="req"/>, specify either :
				<list type="bullet">
					<item>
						<c>req.Where(o => o.Id == Id)</c> if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>. In
						that case, <paramref name="objs"/> is the Id.
					</item>
					<item>
						otherwise, <c>req.Where(o => o.Key1 = KeyValue1)....Where(o => o.Keyn = KeyValuen)</c>. In that case,
						<paramref name="objs"/> is the array containing <c>{ KeyValue1, ..., KeyValuen }</c>
					</item>
				</list>
			</summary>
			<typeparam name="T">The type of the objects of the query</typeparam>
			<param name="req">The query</param>
			<param name="objs">Either the Id or the keys</param>
			<returns>The query specified</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryTryPredicateWhere``1(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
			<summary>
				From a query <paramref name="req"/>, specify that elements must satisfy a predicate <paramref name="predicateWhere"/>.
				<br/>
				If <paramref name="predicateWhere"/> fails to be interpreted from LINQ to SQL, the predicate will be ignored.
			</summary>
			<remarks>TODO(?) : log the error ? Throw custom exception ?</remarks>
			<typeparam name="T">The type of the objects of the query</typeparam>
			<param name="req">The query</param>
			<param name="predicateWhere">The predicate</param>
			<returns>The query specified</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.WhereSkipTake``1(System.Linq.IQueryable{``0},System.Int32,System.Int32,System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
			<summary>
				Specify a query <paramref name="orderedreq"/> (ordered) to get elements following the condition <paramref name="predicateWhere"/> from element <paramref name="start"/> with at most <paramref name="maxByPage"/> elements
				<br/>
				If <paramref name="predicateWhere"/> fails to be interpreted from LINQ to SQL, the predicate will be ignored.
			</summary>
			<param name="orderedreq">The ordered query to specify</param>
			<param name="start">Starting index</param>
			<param name="maxByPage">Maximum number of elements</param>
			<param name="predicateWhere">Conidition</param>
			<returns>The query</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.GetMethodGetKey``1(System.String)">
			<summary>
				Get the <see cref="T:System.Reflection.MethodInfo"/> of <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsExpressionTrees.GetKey``2(System.Reflection.PropertyInfo)"/> where
				<c>TItem</c> is <typeparamref name="T"/> and <c>TKey</c> is the type of the property of <typeparamref name="T"/>
				having the name <paramref name="propertyName"/>.
				<br/>
				The purpose is to dynamically call the generic method <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsExpressionTrees.GetKey``2(System.Reflection.PropertyInfo)"/>.
			</summary>
			<typeparam name="T">The type investigated</typeparam>
			<param name="propertyName">The name of the property.</param>
			<returns>The method.</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.GetMethodOrderBy``1(System.String)">
			<summary>
				Get the <see cref="T:System.Reflection.MethodInfo"/> of <see cref="M:System.Linq.Queryable.OrderBy``2(System.Linq.IQueryable{``0},System.Linq.Expressions.Expression{System.Func{``0,``1}})"/>
				where <c>TSource</c> is <typeparamref name="T"/> and <c>TKey</c> is the type of the property of <typeparamref name="T"/>
				having the name <paramref name="propertyName"/>.
			</summary>
			<typeparam name="T">The type investigated</typeparam>
			<param name="propertyName">The name of the property</param>
			<returns>The method.</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.OrderByCustomKeyFromMethods``1(System.Linq.IQueryable{``0},System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.String)">
			<summary>
				From the methods <paramref name="methodOrderBy"/> and <paramref name="methodGetKey"/>, representing
				respectively the <see cref="T:System.Reflection.MethodInfo"/> given by <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.GetMethodOrderBy``1(System.String)"/> and
				<see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.GetMethodGetKey``1(System.String)"/>, specify the query <paramref name="req"/> appropriately.
				<br/>
				Intent : to specify the query : <c>req.OrderBy(o => o.</c><paramref name="propertyName"/><c>)</c>
				dynamically, so that LINQ to SQL interpretation will be successfull.
			</summary>
			<typeparam name="T">The type invistigated</typeparam>
			<param name="req">The query to specify</param>
			<param name="methodOrderBy">The method OrderBy</param>
			<param name="methodGetKey">The method GetKey</param>
			<param name="propertyName">The name of the property</param>
			<returns>The specified query</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryOrderByKey``1(System.Linq.IQueryable{``0},System.String)">
			<summary>
				Specify the query <paramref name="req"/> ordering elements by <paramref name="defaultPropertyName"/>,
				essentially do <c>req.OrderBy(o => o.</c><paramref name="defaultPropertyName"/><c>)</c> dynamically.
			</summary>
			<typeparam name="T">The type invistigated</typeparam>
			<param name="req">The query to specify</param>
			<param name="defaultPropertyName">The name of the property</param>
			<returns>The specified query</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.QueryDefaultOrderBy``1(System.Linq.IQueryable{``0})">
			<summary>
				Specifies a query <paramref name="req"/> with a default ordering, ordering by either :
				<list type="bullet">
					<item>
						Id if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						otherwise, the first key (the first declared in the class <typeparamref name="T"/>).
					</item>
				</list>
			</summary>
			<typeparam name="T">The type investigated</typeparam>
			<param name="req">The query to specify</param>
			<returns>The specified query.</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.ListWherePropNotNull``1(System.Collections.Generic.List{``0},System.String)">
			<summary>
				From a list <paramref name="lst"/> of elements of type <typeparamref name="T"/>, get all the elements for which
				the property <paramref name="propname"/> is not <see langword="null"/>.
			</summary>
			<typeparam name="T">The type of the elements</typeparam>
			<param name="lst">The input list</param>
			<param name="propname">The name of the property</param>
			<returns>
				The list restricted to elements for which the property <paramref name="propname"/> is not <see langword="null"/>
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.ListWherePropKeysAre``2(System.Collections.Generic.List{``1},System.String,System.Object[])">
			<summary>
				From a list <paramref name="req"/> of elements of class <typeparamref name="Q"/> having a property of type <typeparamref name="T"/>
				with name <paramref name="propname"/>, get the elements for which this property's Id or Keys are given.
				<br/>
				Essentially, does <c>req.Where(q => q.propname.Id == id)</c> or <c>req.Where(q => q.propname.Key1 == keyValue1 &amp;&amp; ... &amp;&amp; q.propname.Keyn == keyValuen)</c>
			</summary>
			<remarks>
				Assumes q.propname is not <see langword="null"/> (otherwise q.propname.something would throw exception)
			</remarks>
			<typeparam name="T">The type of the property</typeparam>
			<typeparam name="Q">The type of the list's elements</typeparam>
			<param name="req">The initial list</param>
			<param name="propname">The property</param>
			<param name="objs">Either the Id or the keys</param>
			<returns>The list specified</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.ListWhereKeysAreCountSup1``1(System.Collections.Generic.IList{``0},System.Object[])">
			<summary>
				From a list <paramref name="req"/> of elements of type <typeparamref name="T"/>,
				return <see langword="true"/> if the list contains an element with either Id or keys <paramref name="objs"/>,
				and return <see langword="false"/> otherwise.
			</summary>
			<typeparam name="T">The type of elements</typeparam>
			<param name="req">The initial list</param>
			<param name="objs">Either the Id or the keys.</param>
			<returns>
				A boolean indicating whether or not the list <paramref name="req"/> contains an element
				with either Id or keys <paramref name="objs"/>
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.ListWherePropListCountainsElementWithGivenKeys``2(System.Collections.Generic.List{``1},System.Type,System.String,System.Object[])">
			<summary>
				From a list <paramref name="req"/> of elements <typeparamref name="Q"/>, get specific elements according to
				the predicate <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsExpressionTrees.ExpressionListWherePropListCountainsElementWithGivenKeys``2(System.Reflection.PropertyInfo,System.Object[])"/>
				applied to the property of <typeparamref name="Q"/> with name <paramref name="propname"/> and either the Id
				or the keys given by <paramref name="objs"/>.
				<br/>
				Ie the elements of type <typeparamref name="Q"/> have a property with name <paramref name="propname"/>
				which is a list of elements of type <typeparamref name="T"/>.
				<br/>
				This returns essentially : <c>req.Where(q => q.prop.Where(t => t.keysorId == objs).Count() >= 1)</c>
				<br/>
				That is to say the list of elements of type <typeparamref name="Q"/> so that their property with name <paramref name="propname"/> is
				a <see cref="T:System.Collections.Generic.IList`1"/> which contains an element with either Id or Key given by <paramref name="objs"/>.
			</summary>
			<remarks>
				Note that <paramref name="q"/> must be the same as <typeparamref name="Q"/>.
			</remarks>
			<typeparam name="T">The type of the property</typeparam>
			<typeparam name="Q">
				The type of the elements in the initial list <paramref name="req"/>
			</typeparam>
			<param name="req">The initial list</param>
			<param name="q">
				The type of the elements in <paramref name="req"/>
			</param>
			<param name="propname">
				The name of the property of <typeparamref name="Q"/> which is of type <typeparamref name="T"/>
			</param>
			<param name="objs">Either the Id or keys</param>
			<returns>The restricted list.</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.ListWherePropListCountainsOnlyElementWithGivenKeys``2(System.Collections.Generic.List{``1},System.Type,System.String,System.Object[])">
			<summary>
				From a list <paramref name="req"/> of elements <typeparamref name="Q"/>, get specific elements according to
				the predicate <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsExpressionTrees.ExpressionListWherePropListCountainsOnlyElementWithGivenKeys``2(System.Reflection.PropertyInfo,System.Object[])"/>
				applied to the property of <typeparamref name="Q"/> with name <paramref name="propname"/> and either the Id
				or the keys given by <paramref name="objs"/>.
				<br/>
				Ie the elements of type <typeparamref name="Q"/> have a property with name <paramref name="propname"/>
				which is a list of elements of type <typeparamref name="T"/>.
				<br/>
				This returns essentially : <c>req.Where(q => q.prop.Where(t => t.keysorId == objs).Count() == 1 &amp;&amp; q.prop.Count() == 1)</c>
				<br/>
				That is to say the list of elements of type <typeparamref name="Q"/> so that their property with name <paramref name="propname"/> is
				a <see cref="T:System.Collections.Generic.IList`1"/> which contains only an element with either Id or Key given by <paramref name="objs"/>.
			</summary>
			<remarks>
				Note that <paramref name="q"/> must be the same as <typeparamref name="Q"/>.
			</remarks>
			<typeparam name="T">The type of the property</typeparam>
			<typeparam name="Q">
				The type of the elements in the initial list <paramref name="req"/>
			</typeparam>
			<param name="req">The initial list</param>
			<param name="q">
				The type of the elements in <paramref name="req"/>
			</param>
			<param name="propname">
				The name of the property of <typeparamref name="Q"/> which is of type <typeparamref name="T"/>
			</param>
			<param name="objs">Either the Id or keys</param>
			<returns>The restricted list.</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.ListRemoveElementWithGivenKeys``1(System.Collections.Generic.List{``0},System.Object[])">
			<summary>
				From a list of elements of type <typeparamref name="T"/> and either a given Id or given keys
				<paramref name="objs"/>, get all the elements that does not either have the Id or one of the given keys.
				<br/>
				Essentially, do <c>req => req.Where(t => t.Id != id)</c> or
				<c>req => req.Where(t => t.key1 != key1value || ... || t.keyn != keynvalue</c>
			</summary>
			<typeparam name="T">The type invistigated</typeparam>
			<param name="req">The initial list</param>
			<param name="objs">Either the Id or the keys</param>
			<returns>The restricted list</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.ListWhereMultiplePropKeysAre``2(System.Collections.Generic.List{``1},System.Collections.Generic.List{System.String},System.Object[])">
			<summary>
				From a list <paramref name="req"/> of elements of class <typeparamref name="Q"/> having mutiple properties
				of type <typeparamref name="T"/> with names <paramref name="propnames"/>, get the elements for which these
				property's Id or Keys are given.
				<br/>
				Essentially, does <c>req.Where(q => q.propname1.Id == id &amp;&amp; ... &amp;&amp; q.propnamen.Id == id)</c>
				or <c>
					req.Where(q => q.propname1.Key1 == key1Value &amp;&amp; ... &amp;&amp; q.propname1.Keym == keymValue
					&amp;&amp; ... &amp;&amp;  q.propnamen.Key1 == key1Value &amp;&amp; ... &amp;&amp; q.propnamen.Keym == keymValue)
				</c>
			</summary>
			<remarks>
				Assumes q.propnames are not <see langword="null"/> (otherwise q.propname.something would throw exception)
			</remarks>
			<typeparam name="T">The type of the property</typeparam>
			<typeparam name="Q">The type of the list's elements</typeparam>
			<param name="req">The initial list</param>
			<param name="propnames">The property</param>
			<param name="objs">Either the Id or the keys</param>
			<returns>The restricted list</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsQueriesAndLists.ListWhereOtherTypePropListNotContains``2(System.Collections.Generic.List{``1},``0,System.String,System.Int32)">
			<summary>
				Get an expression tree having principal root of type <typeparamref name="Q"/>, for testing whether or not an element
				<paramref name="newitem"/> of type <typeparamref name="T"/> with property <paramref name="tpropname"/> of type <see cref="T:System.Collections.Generic.IList`1"/>
				does not contain the element tested.
				<br/>
				Essentially, does <c>req => req.Where(q => !newitem.tpropname.Where(qq => qq.Id == q.Id).Count() == 1))</c>
			</summary>
			<typeparam name="T">
				The type of the <paramref name="newitem"/>
			</typeparam>
			<typeparam name="Q">The type of the elements invistigated</typeparam>
			<param name="req">The list</param>
			<param name="newitem">The object</param>
			<param name="tpropname">
				The name of the property of <typeparamref name="T"/> in question
			</param>
			<param name="nbr">
				The number of keys for objects of type <typeparamref name="Q"/> if appropriate
			</param>
			<returns>The restricted list</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.TryListOfWhat(System.Type,System.Type@)">
			<summary>
				Test if a type <paramref name="type"/> implements <see cref="T:System.Collections.IList"/> of <paramref name="innerType"/>, and if so, determine <paramref name="innerType"/>.
			</summary>
			<remarks>
				Thanks internet for this one.
			</remarks>
			<param name="type">
				Type to test : check if it is <see cref="T:System.Collections.Generic.IList`1"/>
			</param>
			<param name="innerType">
				If <paramref name="type"/> is <see cref="T:System.Collections.Generic.IList`1"/>, returns the inner type <paramref name="innerType"/>
			</param>
			<returns>
				A boolean representing if <paramref name="type"/> is of type <see cref="T:System.Collections.Generic.IList`1"/>
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.KeyPropertiesNames``1">
			<summary>
				Get the names of the properties of <typeparamref name="T"/> that have the annotation
				<see cref="T:System.ComponentModel.DataAnnotations.KeyAttribute"/>. The order will be the same as the order in the declaration of <typeparamref name="T"/>.
			</summary>
			<remarks>
				If <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>, returns <see langword="null"/>.
			</remarks>
			<typeparam name="T">The type invistigated.</typeparam>
			<returns>
				The properties names that are keys, in the same order as in the declaration of <typeparamref name="T"/>. If
				<typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>, returns <see langword="null"/>.
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.HasDynamicDBTypeOrListType``1">
			<summary>
				Tells if <typeparamref name="T"/> is in a relationship with any other class in DB.
			</summary>
			<typeparam name="T">The type invistigated.</typeparam>
			<returns>
				<see langword="true"/> if <typeparamref name="T"/> is in any relationship, <see langword="false"/> otherwise.
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.DynamicDBListTypes``1">
			<summary>
				An object <c>obj</c> of class <typeparamref name="T"/> has properties <c>obj.PropName</c> of
				class <see cref="T:System.Collections.IList"/>&lt;<c>ClassType</c>&gt; where <c>ClassType</c> is in a <see cref="T:System.Data.Entity.DbSet"/> of the generic repository.
				<br/>
				This is every { PropName : ClassType }
			</summary>
			<typeparam name="T">The type invistigated.</typeparam>
			<returns>The dictionary</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.DynamicDBTypes``1">
			<summary>
				An object <c>obj</c> of class <typeparamref name="T"/> has properties <c>obj.PropName</c> of
				class <c>ClassType</c> which is in a <see cref="T:System.Data.Entity.DbSet"/> of the generic repository.
				<br/>
				This is every { PropName : ClassType }
			</summary>
			<typeparam name="T">The type invistigated.</typeparam>
			<returns>The dictionary</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.DynamicDBListTypesForType(System.Type)">
			<summary>
				An object <c>obj</c> of type <paramref name="t"/> has properties <c>obj.PropName</c> of
				class <see cref="T:System.Collections.IList"/>&lt;<c>ClassType</c>&gt; where <c>ClassType</c> is in a <see cref="T:System.Data.Entity.DbSet"/>.
				<br/>
				This is every { PropName : ClassType }
			</summary>
			<param name="t">The type invistigated.</param>
			<returns>The dictionary</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.DynamicDBTypesForType(System.Type)">
			<summary>
				An object <c>obj</c> of type <paramref name="t"/> has properties <c>obj.PropName</c> of
				class <c>ClassType</c> which is in a <see cref="T:System.Data.Entity.DbSet"/>.
				<br/>
				This is every { PropName : ClassType }
			</summary>
			<param name="t">The type invistigated.</param>
			<returns>The dictionary</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.CheckIfObjectIsKey``1(System.Object[])">
			<summary>
				Checks if <paramref name="objs"/> is either
				<list type="bullet">
					<item>
						an integer, the Id, if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						an array (of proper length) of objects (of proper types) corresponding to the keys of <typeparamref name="T"/>.
					</item>
				</list>
			</summary>
			<typeparam name="T">The type invistigated.</typeparam>
			<param name="objs">The array of object tested.</param>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.ObjectsToId``1(System.Object[])">
			<summary>
				From an array of objects, supposed to be either Id or keys, get the Id
			</summary>
			<typeparam name="T">The type investifated</typeparam>
			<param name="objs">The objects to cast to int as an Id</param>
			<returns>The Id</returns>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.GetKeysValues``1(``0)">
			<summary>
				From an object <paramref name="t"/> of type <typeparamref name="T"/>, get either
				<list type="bullet">
					<item>
						the id of <paramref name="t"/> if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						otherwise the array of keys of <paramref name="t"/>
					</item>
				</list>
			</summary>
			<typeparam name="T">The type invistigated</typeparam>
			<param name="t">The object</param>
			<returns>
				Either the Id of <paramref name="t"/> or its keys values
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.GetKeysValuesForType(System.Object,System.Type)">
			<summary>
				Call the generic method <see cref="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.GetKeysValues``1(``0)"/> dynamically.
				<br/>
				That is, get either the Id or the keys values
				of an object <paramref name="item"/> of type <paramref name="typeofElement"/>.
			</summary>
			<param name="item">The item</param>
			<param name="typeofElement">The type of the object</param>
			<returns>
				Either the Id or the keys values of <paramref name="item"/>
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.CheckIfObjsIsManyKeys``1(System.Object[])">
			<summary>
				Assuming <typeparamref name="T"/> does not derive from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>, check
				if <paramref name="objs"/> is an array of keys.
			</summary>
			<typeparam name="T">The type invistigated</typeparam>
			<param name="objs">The array that must be many keys values.</param>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException"/>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.GetManyKeys``1(System.Object[])">
			<summary>
				From a one dimensionnal array of keys values <paramref name="objs"/>, get an array
				of array containing key values.
				<br/>
				<example>
					From <c>{ key1value1, key2value1, key1value2, key2value2 }</c> get
					<c>{ { key1value1, key2value1 } , { key1value2, key2value2 } }</c>
				</example>
			</summary>
			<typeparam name="T">The type invistigated</typeparam>
			<param name="objs">The array of keys values</param>
			<returns>The array of array containing key values.</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.CheckIfObjsIsManyKeysOrIds``1(System.Object[])">
			<summary>
				Checks if <paramref name="objs"/> is either
				<list type="bullet">
					<item>
						many Ids if <typeparamref name="T"/> derives from <see cref="T:GenericRepositoryAndService.Models.BaseEntity"/>
					</item>
					<item>
						or many keys values.
					</item>
				</list>
			</summary>
			<typeparam name="T">The type invistigated</typeparam>
			<param name="objs">The array that must either be many Ids or manys keys values.</param>
			<exception cref="T:GenericRepositoryAndService.Exceptions.IdListEmptyForClassException"/>
			<exception cref="T:GenericRepositoryAndService.Exceptions.InvalidKeyForClassException" />
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.GetManyIds(System.Object[])">
			<summary>
				From an array <paramref name="objs"/> of objects containing many Ids,
				get an array <see cref="T:System.Int32"/>?[] containing the Ids.
			</summary>
			<param name="objs">The array to convert.</param>
			<returns>The array of Ids.</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.HasPropertyRelation(System.Type,System.Type)">
			<summary>
				Return <see langword="true"/> if and only if <paramref name="t1"/> has a property of type either <paramref name="t2"/>
				or <see cref="T:System.Collections.IList"/>&lt;<paramref name="t2"/>&gt;. That is to say that <paramref name="t1"/> and <paramref name="t2"/> are in
				a relationship and that <paramref name="t1"/> has a property concerning this relationship.
			</summary>
			<param name="t1">The type for which properties have to be invistigated</param>
			<param name="t2">
				The type to check whether or not is is in a relationship with <paramref name="t1"/>
				for which <paramref name="t1"/> has a property.
			</param>
			<returns>
				<see langword="true"/> if <paramref name="t1"/> and <paramref name="t2"/> are in
				a relationship and <paramref name="t1"/> has a property concerning this relationship. <see langword="false"/>
				otherwise
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.HasPropertyRelationNotList(System.Type,System.Type)">
			<summary>
				Return <see langword="true"/> if and only if <paramref name="t1"/> has a property of type <paramref name="t2"/>
				That is to say that <paramref name="t1"/> and <paramref name="t2"/> are in
				a relationship and that <paramref name="t1"/> has a property concerning this relationship of type <paramref name="t2"/>
			</summary>
			<param name="t1">The type for which properties have to be invistigated</param>
			<param name="t2">
				The type to check whether or not is is in a relationship with <paramref name="t1"/>
				for which <paramref name="t1"/> has a property of type <paramref name="t2"/>.
			</param>
			<returns>
				<see langword="true"/> if <paramref name="t1"/> and <paramref name="t2"/> are in
				a relationship and <paramref name="t1"/> has a property concerning this relationship of type <paramref name="t2"/>.
				<see langword="false"/> otherwise
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.HasPropertyRelationList(System.Type,System.Type)">
			<summary>
				Return <see langword="true"/> if and only if <paramref name="t1"/> has a property of type <see cref="T:System.Collections.IList"/>&lt;<paramref name="t2"/>&gt;
				That is to say that <paramref name="t1"/> and <paramref name="t2"/> are in
				a relationship and that <paramref name="t1"/> has a property concerning this relationship of type
				<see cref="T:System.Collections.IList"/>&lt;<paramref name="t2"/>&gt;
			</summary>
			<param name="t1">The type for which properties have to be invistigated</param>
			<param name="t2">
				The type to check whether or not is is in a relationship with <paramref name="t1"/>
				for which <paramref name="t1"/> has a property of type <see cref="T:System.Collections.IList"/>&lt;<paramref name="t2"/>&gt;.
			</param>
			<returns>
				<see langword="true"/> if <paramref name="t1"/> and <paramref name="t2"/> are in
				a relationship and <paramref name="t1"/> has a property concerning this relationship of type
				<see cref="T:System.Collections.IList"/>&lt;<paramref name="t2"/>&gt;. <see langword="false"/> otherwise
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.HasPropertyRelationRequired(System.Type,System.Type)">
			<summary>
				Returns whether or not the type <paramref name="t1"/> has a property representing a relationship
				with <paramref name="t2"/>, that is to say of type <paramref name="t2"/> or <see cref="T:System.Collections.IList"/>&lt;<paramref name="t2"/>&gt;
				which has the annotation <see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/>.
			</summary>
			<param name="t1">The type for which properties have to be invistigated</param>
			<param name="t2">
				The type to check whether or not is is in a relationship with <paramref name="t1"/>
				for which <paramref name="t1"/> has a property with the annotation <see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/>.
			</param>
			<returns></returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.GetTypesInRelationWithTHavingTPropertyTAndTNotHavingProperty``1">
			<summary>
				Get all types t that are in relation with <typeparamref name="T"/> so that :
				<list type="bullet">
					<item>
						t has a property representing that relationship, that is to say either of type <typeparamref name="T"/> or <see cref="T:System.Collections.Generic.IList`1"/>
					</item>
					<item>
						<typeparamref name="T"/> has no property representing that relationship.
					</item>
				</list>
			</summary>
			<typeparam name="T">The type invistigated</typeparam>
			<returns>
				The list of types in relationship with <typeparamref name="T"/> that have a property for the relation and
				<typeparamref name="T"/> has no such property.
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.GetTypesInRelationWithTHavingRequiredTProperty``1">
			<summary>
				Get all types t that are in relation with <typeparamref name="T"/> so that :
				<list type="bullet">
					<item>
						t has a property representing that relationship, that is to say either of type <typeparamref name="T"/> or <see cref="T:System.Collections.Generic.IList`1"/>
					</item>
					<item>
						that property is has the annotation <see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/>
					</item>
				</list>
			</summary>
			<typeparam name="T">The type invistigated</typeparam>
			<returns>
				The list of types in relationship with <typeparamref name="T"/> that have a property for the relation
				with the annotation <see cref="T:System.ComponentModel.DataAnnotations.RequiredAttribute"/>
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.HasManyProperties(System.Type,System.Type)">
			<summary>
				Return <see langword="true"/> if and only if <paramref name="t1"/> has many property of type either <paramref name="t2"/>
				or <see cref="T:System.Collections.IList"/>&lt;<paramref name="t2"/>&gt;. That is to say that <paramref name="t1"/> and <paramref name="t2"/> are in
				a relationship and that <paramref name="t1"/> has more than one property concerning this relationship.
			</summary>
			<param name="t1">The type for which properties have to be invistigated</param>
			<param name="t2">
				The type to check whether or not is is in a relationship with <paramref name="t1"/>
				for which <paramref name="t1"/> has more than one property.
			</param>
			<returns>
				<see langword="true"/> if <paramref name="t1"/> and <paramref name="t2"/> are in
				a relationship and <paramref name="t1"/> has more than one property concerning this relationship. <see langword="false"/>
				otherwise
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.GetTypesForWhichTHasManyProperties``1">
			<summary>
				Get the list of types t that are many relationships with <typeparamref name="T"/>, that is to say that
				<typeparamref name="T"/> has many properties of types either t or <see cref="T:System.Collections.IList"/>&lt;t&gt;.
			</summary>
			<typeparam name="T">The type invistigated</typeparam>
			<returns>The list of types</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.GetTypesForWhichTHasOneProperty``1">
			<summary>
				Get the list of types t that are in exactly one relationship with <typeparamref name="T"/>, that is to say that
				<typeparamref name="T"/> has exactly one property of types either t or <see cref="T:System.Collections.IList"/>&lt;t&gt;.
			</summary>
			<typeparam name="T">The type invistigated</typeparam>
			<returns>The list of types</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.NbrOfKeys(System.Type)">
			<summary>
				Get the number of keys of type <paramref name="q"/> if appropriate
			</summary>
			<param name="q">The type invistigated</param>
			<returns>
				The number of keys of type <paramref name="q"/>, 1 if it has an Id, and 0 otherwise.
			</returns>
		</member>
		<member name="M:GenericRepositoryAndService.Tools.Generic.GenericToolsTypeAnalysis.PropNamesForRelationWithTWithRequired(System.Type,System.Type)">
			<summary>
				For two types <paramref name="t1"/>, <paramref name="t2"/>, get a Dictionnary of property names (key, value) such that :
				<list type="bullet">
					<item>
						There is a relationship between <paramref name="t1"/> and <paramref name="t2"/>
					</item>
					<item>
						The corresponding property of <paramref name="t1"/> has name key
					</item>
					<item>
						The corresponding property of <paramref name="t2"/> is required and has name value
					</item>
				</list>
			</summary>
			<param name="t1">The first type</param>
			<param name="t2">The second type</param>
			<returns>The dictionnary</returns>
		</member>
	</members>
</doc>
